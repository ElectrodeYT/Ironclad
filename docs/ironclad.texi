\input texinfo
@setfilename ironclad.info
@documentencoding UTF-8
@settitle Kernel interfaces

@copying
Copyright @copyright{} 2022 streaksu

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@title Ironclad kernel and userland interface
@subtitle Methods to interface with the kernel from boot-time and userland.
@author streaksu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents

@ifnottex
@node Top
@top Ironclad
@insertcopying
@end ifnottex

@menu
* General information::              General information about the project
* Boot-time command-line options::   Command-line options
* Embedded facilities and RTC::      Features and interfaces for embedded work
* Memory allocation algorithms::     The avaiable allocation algorithms.
* Syscalls::                         The main method of userland to interface
* Devices and their properties::     Devices exposed by the kernel
* GNU Free Documentation License::   Copying and sharing this manual

@detailmenu
--- The Detailed Node Listing ---

General information

* Audience::                The people for whom this manual is written.
* How to contribute::       How to contribute code to the kernel.
* Error reporting::         How to report issues with the kernel.
* Navigating the source::   Structure of the project.
* Formal verification::     Current state of the formal verification effort.

Boot-time command-line options

* Format::                 Description of the format.
* List::                   List of all the available cmdline arguments.

Embedded facilities and RTC

* Ticks and other interruptions::     Thread interruptions to expect.
* Scheduling and predictability::     Scheduling in Ironclad in depth.

Memory allocation algorithms

* standard::             The standard allocator.
* alloconly::            The low profile allocator that does not free.

Userland state and conditions

* Program loading and ld.so::  Format of the loaded programs.
* Memory layout::              Layout of the memory in userland.

Mandatory access control

* How to configure MAC::      How MAC is configured.

Syscalls

* x86_64::                  x86_64 syscall ABI and table.
* Errno::                   Error conditions and their values.
* exit::                    Exit the callee process.
* arch_prctl::              Interacting with architectural thread-local data.
* open/close::              Opening and closing a file.
* read/write::              Read and write from an already opened file.
* seek::                    Modify and fetch file offsets.
* mmap/munmap::             Memory mapping and requesting.
* getpid/getppid::          Get the PIDs of the caller.
* exec::                    Launching new programs.
* fork::                    Fork current state into a new process.
* wait::                    Waiting for execution of a child to finish.
* uname::                   Fetch basic system information.
* sethostname::             Hostname setting.
* fstat/lstat::             Fetch file information.
* getcwd/chdir::            Current working directory manipulation.
* ioctl::                   IO multiplexer.
* sched_yield::             Relinquish CPU time.
* set_deadlines::           Manage scheduler deadlines.
* dup/dup2/dup3::           Duplicate file descriptors.
* access::                  Testing file permissions.
* thread_sched::            Manage scheduler-related thread permissions.
* fcntl::                   Multiplexed operations for files.
* spawn::                   Start separate programs by path.
* getrandom::               Bypass /dev/random for avoiding DoS attacks.
* mprotect::                Change memory permissions.
* crypto_request::          Access to kernel crypto ala /dev/crypto.
* set_mac_capabilities::    Modify MAC capabilities.
* lock_mac::                Lock MAC down.
* add_mac_filter::          Configure MAC using filesystem-based filters.
* set_mac_enforcement::     Set enforcement to follow on MAC violations.

Devices and their properties

* Common devices::             Devices common to all architectures and targets.
* aarch64-stivale2 devices::   Devices specific to aarch64-stivale2.
* sparc-leon3 devices::        Devices specific to sparc-leon3.
* x86_64-multiboot2 devices::  Devices specific to x86_64-multiboot2.

@end detailmenu
@end menu

@node General information
@chapter General information

As the README of the project states, Ironclad is a kernel for x86_64 devices
exclusively (for now), written in Ada. The goal of the project is to create
a POSIX kernel for hobbyist fun, maybe one day for real life use. Ironclad has
a lot of features one would expect on a modern system, and the list only
continues to grow, like support for desktop environments, true multitasking, a
good memory manager, and a fully functional userland with dynamic linking and
ELF loading.

@node Audience
@section Audience

This manual is designed to document and give information about the several
interfaces and devices Ironclad exposes, so developers of userland applications
and other programmers can read inner details of how to interface with the
kernel without having to navigate the (often cryptic and scary Ada) code.

@node How to contribute
@section How to contribute

Thanks for considering contributing to Ironclad, it means a lot.

There are several ways one can help the Ironclad project, from writing and
correcting documentation to contributing source.

For submitting patches, be it for Ironclad's webpages, kernel code, or
documentation, please submit the patch to the project's
@url{https://savannah.nongnu.org/patch/?group=ironclad, patch manager},
(@url{https://savannah.nongnu.org/patch/?group=ironclad&func=additem, create an item}).

If prefered, one can send a patch in
@email{bug-ironclad@@nongnu.org, bug-ironclad}.

When contributing code, it's good to keep in mind these guidelines:

@enumerate
@item
One may only contribute code that complies with the project's license, or code
ruled by GPL-compatible licenses under certain conditions, its the
responsability of the contributor to ensure this is the case.

@item
Add license headers and detail the authors of the code. For files with a main
author and small touches being done on top of it, you can update the authors in
the copyright to `Copyright (C) 2022 [main author's name], et. al.`, or add
your name or pseudonym for a major contribution to the comma-separated list.

@item
It goes a long way to add the relevant documentation as comments and standalone
documentation when considered necessary. While not necessary, you save me the
trouble of having to add it later. :D
@end enumerate

@node Error reporting
@section Error reporting

Ironclad is a fairly new project at the end of the day, so things are prone to
fail. Once an issue arises, one can open a bug report at the
@url{https://savannah.nongnu.org/bugs/?group=ironclad, project's bug tracker},
(@url{https://savannah.nongnu.org/bugs/?group=ironclad&func=additem, create an item}).

@node Navigating the source
@section Navigating the source

The source of Ironclad can be found on its repository under the @code{source}
directory. It has several subdirectories with the following meanings:

@table @code
@item arch
Architecture-dependent code.

@item cryptography
Cryptographic facilities, cypher implementations, entropy management.

@item devices
Several device drivers, physical and virtual.

@item lib
Functions and libraries for utilities used in the rest of the kernel.

@item memory
Memory management, physical as well as virtual.

@item networking
Networking drivers and data.

@item userland
Userland code for loaders, processes, and such.

@item vfs
VFS structure and FS drivers.
@end table

Apart of those subdirectories, @code{source} contains the @code{main.adb} of
the kernel, @code{pragmas.adc} containing the pragmas used for the rest of the
kernel code, and some other files and drivers that do not fit in the former
subdirectories.

The code under @code{tests} does some general testing of facitilities that
can be tested outside a final Ironclad binary.

@node Formal verification
@section Formal verification

Right now the source of Ironclad is ongoing a process to raise its verification
status to @url{https://docs.adacore.com/spark2014-docs/html/ug/en/usage_scenarios.html#levels-of-spark-use, a mix of silver and gold level}.
This is done with the goal of ensure the absence of errors in a crucial system
component like the kernel, and for ensuring the suitability of Ironclad for
embedded and mission critical tasks.

@node Boot-time command-line options
@chapter Boot-time command-line options

Ironclad takes, as part of its boot protocol, a series of options and values.
The parsing of this options is architecture and platform independent, while the
ability to modify said options and values is entirely up to the platform and
bootloader.

@node Format
@section Format

The format is a list of keys that can have arguments or not in a C-style
NUL-terminted string, as such:

@example
key1=value1 key2 key3 ... keyN
@end example

@node List
@section List

This are the keys and values the kernel takes, and under which circumstances:

@table @code
@item root=<device>
Device to mount as root, if any.

@item init=<path>
Path to a program that will be booted by the kernel when finished loading.
The program will be started with @code{stdin} set to @code{/dev/null}, and
@code{stdout} and @code{stderr} set to @code{/dev/debug}.

@item syscalltracing
Enables tracing syscalls and their arguments, really performance taxing, but
essential for userland kernel debugging.
@end table

@node Embedded facilities and RTC
@chapter Embedded facilities and RTC

Ironclad supports several features geared towards embedded and real time work,
this section approaches what to expect and how to interact with the features.

@node Ticks and other interruptions
@section Ticks and other interruptions

Ironclad will not interrupt your running thread for timer or heartbeats, in
that way, ironclad is tickless.

However, Ironclad can interrupt a process for scheduling-related stops, this
is totally normal and can introduce substantial delays on systems with a lot
of processes, or introduce jitter on systems that desire absolutely 0 stops.

For how to get around scheduling-related ticks, read about @code{THREAD_MONO}
at @pxref{Scheduling and predictability}.

@node Scheduling and predictability
@section Scheduling and predictability

Scheduling in Ironclad is done using Rate-Monotonic Scheduling (RMS) to
ensure deadlines. This puts contraints on the threads a user can create and
how.

@subsection Predictability and guarantees

The sequence of scheduled tasks is fully predictable, and they are executed in
a round robin, once priorities have been given by RMS.

Thanks to RMS, deadlines are mathematically guaranteed to be met as long as an
upper bound of CPU time utilization is not exceeded. Said bound can be
calculated using the number of tasks following the schedulability test:

@tex
$$ \sum_{i=1}^{n}{U_i}=\sum_{i=1}^{n}{C_i \over T_i}\leq n([2^{1/n}]-1) $$
@end tex

Where:

@table @math
@item U_i
CPU time utilization of a thread.
@item C_i
CPU time needed by the thread.
@item T_i
Period of the thread.
@item n
Number of threads to be scheduled.
@end table

When the number of threads tends to infinity, the condition tends to:

@tex
$$ \lim_{n\rightarrow\infty}n([2^{1/n}]-1)=\ln 2\approx 0.693147\ldots $$
@end tex

The kernel will just always compare with this approximated value for
simplicity and due to floating-point limitations. If this quick test is not
passed, the kernel will warn about it, but will not refuse to schedule, since
the user might know better, or may not want to respect deadlines at all.

Since the kernel leaves the responsability (and priviledge) of ensuring a
correct scheduling setup to the user, this opens the door to a number of tricks
to break through the 69% usage ceiling, while keeping deadlines alive and well.

@table @code
@item Harmonic chains and task periods
Thanks to the @url{https://ieeexplore.ieee.org/document/160369, work of Kuo and Mok},
we know that for harmonic sets of tasks, the schedulability test becomes:
@tex
$$ \sum_{i=1}^{n}{U_i}=\sum_{i=1}^{n}{C_i \over T_i}\leq K([2^{1/K}]-1) $$
@end tex

Where @math{K} is the number of harmonic sets, for @math{1}, the utilization
becomes 100%.

A harmonic set of tasks is the set where every task evenly divides the period
of every longer period. For example, a harmonic set of 3 tasks periods is
@code{@{20, 60, 120@}}
@end table

@subsection Monothreading

Scheduling in Ironclad supports creating critical sections backed by the kernel
using @pxref{thread_sched} and @code{THREAD_MONO}.

This flag will make the scheduler not preemt at all from the thread until
rqeuested, by using @xref{sched_yield} or relinquishing execution in any other
similar way. Doing that will not reset the flag, but it will allow the system
to search for another possibly preemtible thread.

Note that this flag only applies to the core to request the scheduling, other
cores in the system will continue to preempt as usual.

@node Memory allocation algorithms
@chapter Memory allocation algorithms

Ironclad features several memory allocator choices for use by the userland
and kernel.

@node standard
@section standard

The standard allocator is a bitmap-based, simple allocator with 4K-sized
blocks.

The allocator allows freeing, it suffers from heavy fragmentation when
frequenty using big allocations, and takes a relative lot of memory to keep
track of status.

@node alloconly
@section alloconly

The 'alloconly' allocator is an alternative, bump-based allocator that is
much faster and uses way less memory than the standard allocator, while not
being able to free as its biggest trade-off.

This allocator is appropiate for embedded applications that are recommended
to allocate all the program will ever need at the beggining of its execution,
and thats it.

@node Userland state and conditions
@chapter Userland state and conditions

Ironclad places several requirements on loaded userland programs, from the
format of which, to memory layout.

@node Program loading and ld.so
@section Program loading and ld.so

Loaded programs must be under the ELF64 format, other formats may be supported
in the future. Loaded programs can be relocatable or not.

@code{ld.so} is a special case, it's loaded from the information on the headers
of the primary loaded program, and is assumed to be relocatable (static-PIE).

@node Memory layout
@section Memory layout

Loaded programs are loaded at address 0, and they are free to allocate
themselves at nearby offsets.

@code{ld.so} and entities like stacks, anonymous memory regions, and others,
will be randomized on load time following
@uref{https://en.wikipedia.org/wiki/Address_space_layout_randomization, ASLR},
and must not be relied upon. It is up to @code{ld.so} to optionally place
additionally loaded libraries at random offsets.

@node Mandatory access control
@chapter Mandatory access control

Mandatory access control (MAC) forms one of the main components of Ironclad
security.

With several restrictive settings that are inherited from parent processes to
children, we can ensure processes will only have access to the minimum
required set of permissions for their task.

MAC does not necesarily help with preventing breaches of security, but
minimizes the things a breached process can do, when configured correctly.

@node How to configure MAC
@section How to configure MAC

A series of coarse permissions, called capabilities, that restrict the process
on what it can and cannot do, can be done by using @ref{set_mac_capabilities}.

Apart of capabilities, access to filesystem structures and permission
management can be done using @ref{add_mac_filter}.

The method of acting on MAC violations and failures can be set by using
@ref{set_mac_enforcement}. Possible values include denying requests, killing
the offending part outright, or denying and additionally logging the event.

Locking can be done with @ref{lock_mac}. Once locked, MAC setup is done, and
it comes into effect. When locked, processes can only restrict themselves
further, but not make them more permissive. Locking is not reversible.

MAC is meant to be configured and locked in a parent process like init in a
classic UNIX-like boot. There, the init can configure the desired processes
to be launched under the necessary permissions.

The permissions of the parent process booted by the kernel as passed in
the @code{init} cmdline option are all denied.

For example:

@example
int main(void) @{
    // Set our permissions and spawn a child, the child will inherit them.

    // We create a process that can access to allocation but not deallocation,
    // grant access to entropy, and change its own scheduling.
    if (set_mac_capabilities(MAC_CAN_ALLOC_MEM | MAC_CAN_ACC_ENTROPY |
                             MAC_CAN_CHANGE_SCHED) != 0) @{
        return -1;
    @}
    if (spawn("/usr/bin/example1", NULL, NULL) != 0) @{
        return -1;
    @}

    // Lock, and we are done!
    if (lock_mac() != 0) @{
        return -1;
    @}
@}
@end example

@node Syscalls
@chapter Syscalls

Syscalls in Ironclad have an architecture-dependent ABI, here is a list of the
supported architectures and the ABI for each of them.

@node x86_64
@section x86_64

Syscalls are invoked in Ironclad by triggering an interrupt to vector
@code{0x80}.

The index of the syscall is passed on @code{%rax}, while the return value is
returned on @code{%rax}, errno is returned on @code{%rdx}, arguments are passed
over @code{%rdi}, @code{%rsi}, @code{%rdx}, @code{%rcx}, @code{%r8}, and
@code{%r9}, following the SysV ABI.

The list of syscalls ordered by their index in @code{rax} for the platform is:

@enumerate 0
@item
@xref{exit}.
@item
@xref{arch_prctl}.
@item
@xref{open/close, open}.
@item
@xref{open/close, close}.
@item
@xref{read/write, read}.
@item
@xref{read/write, write}.
@item
@xref{seek}.
@item
@xref{mmap/munmap, mmap}.
@item
@xref{mmap/munmap, munmap}.
@item
@xref{getpid/getppid, getpid}.
@item
@xref{getpid/getppid, getppid}.
@item
@xref{exec}.
@item
@xref{fork}.
@item
@xref{wait}.
@item
@xref{uname}.
@item
@xref{sethostname}.
@item
@xref{fstat/lstat, fstat}.
@item
@pxref{fstat/lstat, lstat}.
@item
@xref{getcwd/chdir, getcwd}.
@item
@xref{getcwd/chdir, chdir}.
@item
@xref{ioctl}.
@item
@xref{sched_yield}.
@item
@xref{set_deadlines, set_deadlines}.
@item
empty
@item
@xref{dup/dup2/dup3, dup}.
@item
@xref{dup/dup2/dup3, dup2}.
@item
@pxref{dup/dup2/dup3, dup3}.
@item
@xref{access}.
@item
@xref{thread_sched, get_thread_sched}.
@item
@xref{thread_sched, set_thread_sched}.
@item
@xref{fcntl}
@item
@xref{spawn}
@item
@xref{getrandom}
@item
@xref{mprotect}
@item
@xref{crypto_request}
@item
@xref{set_mac_capabilities}
@item
@xref{lock_mac}
@item
@xref{add_mac_filter}
@item
@xref{set_mac_enforcement}
@end enumerate

@node Errno
@section Errno

Errno are values returned by the kernel to detail the nature of an error in
depth. When a syscall does not error out, it returns the value 0 on the errno
field. Here is a table of all the possible errno and its values and meaning:

@table @code
@item ERANGE (3)
The passed value was not big enough.

@item EACCES (1002)
The passed access for a variable points to bad memory.

@item EAGAIN (1006)
The requested resource is not available at the moment.

@item ECHILD (1012)
The passed value is not a child process.

@item EFAULT (1020)
The passed value would make the program fault.

@item EINVAL (1026)
The passed value is not valid for the called syscall.

@item EMFILE (1031)
Too many files were opened by the process.

@item ENAMETOOLONG (1036)
The passed value is too big for the syscall.

@item ENOENT (1043)
No such file or directory.

@item ENOSYS (1051)
The requested syscall or flag is not implemented.

@item ESPIPE (1069)
A seek was issued to an invalid device.

@item ESRCH (1070)
The passed item could not be found after a search.

@item ESPIPE (1081)
The passed FD is in a bad state.
@end table

@node exit
@section exit

@example
void exit(uint64_t status);
@end example

This syscall terminates the calling process "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this, rookie mistake.
@end itemize

@node arch_prctl
@section arch_prctl

@example
int arch_prctl(int code, uint64_t argument);
@end example

This syscall interacts with architecture-specific thread-local storage. For
x86_64, these are the available codes:

@table @code
@item ARCH_SET_FS (1)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_FS (2)
Stores the current thread's FS into the variable pointed to by @code{argument}.

@item ARCH_SET_GS (3)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_GS (4)
Stores the current thread's GS into the variable pointed to by @code{argument}.
@end table

This syscall returns @code{0} on success, and @code{-1} on failure.
errno is to be set to the following values on failure:

@itemize @bullet
@item
@code{EINVAL}: @code{code} is not valid.

@item
@code{EFAULT}: @code{argument} is outside the available address space.
@end itemize

@node open/close
@section open/close

@example
int open(char *path, int flags, mode_t mode);
int close(int fd);
@end example

@code{open} opens the passed file, depending on the flags passed, it may create
it if not present. By default, the file descriptor will remain open accross an
@code{exec}, and the file offset is set to the beggining. @code{mode} is used
when creating the file.

The flags can be an OR'd field of the following elements:

@table @code
@item O_RDONLY (0b0001)
Makes the file read-only.

@item O_WRONLY (0b0010)
Makes the file write-only.

@item O_RDWR (0b0011)
Makes the file read/write.

@item O_APPEND (0b0100)
Makes the file be opened at the end of the file, instead of the beggining.

@item O_CREAT (0b1000)
Create the file if it does not exist.
@end table

@code{close} closes an open file descriptor. Once no open references exist of a
file descriptor, its resources are freed, and the file deleted if needed.

@code{open} returns the opened file descriptor or @code{-1} on error.
@code{close} returns 0 on success and -1 in failure.

errno is set according to the conditions for both functions:

@itemize @bullet
@item
@code{ENOENT}: The referenced file for @code{open} does not exist.

@item
@code{EINVAL}: Combination of @code{open} flags is not valid.

@item
@code{EMFILE}: Too many files are already owned by the process.

@item
@code{EFAULT}: The passed path is outside the available address space.

@item
@code{EBADF}: The passed file to @code{close} is not valid.
@end itemize

@node read/write
@section read/write

@example
ssize_t read(int fd, void *buffer, size_t count);
ssize_t write(int fd, void *buffer, size_t count);
@end example

These syscalls attempts to read or write up to passed count from the passed file descriptor.

On files that support seeking, the operation commences at the file offset, and
the file offset is incremented by the number of bytes read or written. If the
file offset is at or past the end of file, no bytes are read or written, and
the operation returns zero.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed fd is not suitable for the operation.
@end itemize

@node seek
@section seek

@example
off_t seek(int fd, off_t offset, int whence);
@end example

This syscall repositions the file offset of the passed file description to the
passed offset according to the directive whence as follows:

@itemize @bullet
@item
@code{SEEK_SET} (1): Set to the passed offset.

@code{SEEK_CUR} (2): Set to the current offset plus the passed offset.

@code{SEEK_END} (4): Set to the size of the file plus the passed offset.
@end itemize

This syscall returns the resulting offset, or @code{-1} on failure. errno is to
be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EINVAL}: The whence is malformed or the resulting offset would be invalid.

@item
@code{ESPIPE}: @code{seek} was called on a TTY or a pipe.
@end itemize

@node mmap/munmap
@section mmap/munmap

@example
void *mmap(void *hint, size_t length, int protection, int flags, int fd, off_t offset);
int munmap(void *address, size_t length);
@end example

@code{mmap} creates a new mapping in the virtual address space of the calling
process. An address can be passed, if it is @code{null}, then the kernel gets
to choose the address, else, it is taken as a hint about where to place the
mapping.

@code{hint} and @code{length} are required to be aligned to page boundaries
for the running architecture, else it will fail.

@code{protection} and @code{flags} are a bitfield of the following flags:

@itemize @bullet
@item
@code{PROT_NONE} (0b0000): No specific protection.

@item
@code{PROT_READ} (0b0001): Read permissions.

@item
@code{PROT_WRITE} (0b0010): Write permissions.

@item
@code{MAP_FIXED} (0b0100): Use hint as a hard requirement.

@item
@code{MAP_ANON} (0b1000): Mapping is not backed by any file.
@end itemize

@code{munmap} will unmap a range for the virtual address space of the calling
process, this values must be the same as passed and returned by @code{mmap},
partial unmapping is not allowed.

@code{mmap} returns a pointer to the allocated area, or @code{-1} on failure.
@code{munmap} returns @code{0} on success, @code{-1} on failure. Both functions
set the following errno:

@itemize @bullet
@item
@code{EINVAL}: Bad hints or parameters.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getpid/getppid
@section getpid/getppid

@example
int getpid();
int getppid();
@end example

@code{getpid} returns the process ID (PID) of the calling process.
@code{getppid} does the same but it returns the one of the parent, which is the
process that created the callee by a myriad of ways.

This functions are always successful.

@node exec
@section exec

@example
int exec(const char *path, char *const argv[], char *const envp[]);
@end example

This syscall executes the program passed with the passed argv and evp, closing
all the threads of the callee process and putting a single one in place for
the new program. Other process-specific elements like file descriptors are
untouched.

This syscall only returns in failure with @code{-1} with the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file passed in path doesnt exist.

@item
@code{EACCES}: The file couldn't be launched out of a permission error.
@end itemize

@node fork
@section fork

@example
pid_t fork(void);
@end example

This syscall creates a new process by duplicating the calling process. The
process is referred to as the child process.The calling process is referred to
as the parent process. The processes run on copied memory, and at the time of
cloning have the same file descriptors open and memory mappings.

The child will only have the callee thread cloned. The other threads, if any,
are not cloned.

This syscall returns @code{0} on success for the child, and the children PID to
the parent, in failure, the parent gets @code{-1} with the following errno:

@itemize @bullet
@item
@code{EAGAIN}: The system could not fork right now, try again later.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node wait
@section wait

@example
pid_t wait(pid_t pid, int *status, int options);
@end example

This syscall suspends execution until the passed pid exits, to then store the
exit code in @code{status}.

@code{wait} allows the option @code{WNOHANG(0b000010)} for non-blocking
waiting, if the process has not finished yet, @code{0} will be returned.

@code{pid} can be a PID the callee is a parent of, or @code{-1} to wait on all
the PIDs the callee has as children. @code{0}, which waits on all the children
of a process group, is not implemented yet.

This syscall returns the PID waited on or @code{-1} on failure, along with the
following errno:

@itemize @bullet
@item
@code{ECHILD}: The passed PID does not exist.

@item
@code{EINVAL}: The passed options are not correct or the passed PID is @code{0}
@end itemize

@node uname
@section uname

@example
struct utsname @{
    char sysname[65];  // Kernel name (e.g., "Ironclad")
    char nodename[65]; // Hostname of the machine.
    char release[65];  // Kernel release (e.g., "2.6.28")
    char version[65];  // Kernel configuration date for debug purposes.
    char machine[65];  // Hardware identifier (e.g., "x86")
@};

int uname(struct utsname *name);
@end example

This syscall reports kernel information, like version, name, and hostname.
It returns @code{0} on success, and @code{-1} on failure, with the only errno
being @code{EFAULT} if the passed pointer is in an invalid address.

@node sethostname
@section sethostname

@example
int sethostname(const char *buffer, size_t length);
@end example

This syscall sets the kernel hostname to the passed string. @code{0} is
returned on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed buffer points to an invalid address.

@item
@code{EINVAL}: The passed length is bigger than the kernel can handle or 0.

@item
@code{EACCES}: MAC did not allow this.
@end itemize

@node fstat/lstat
@section fstat/lstat

@example
struct stat @{
    dev_t st_dev;
    ino_t st_ino;
    mode_t st_mode;
    nlink_t st_nlink;
    uid_t st_uid;
    gid_t st_gid;
    dev_t st_rdev;
    off_t st_size;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    blksize_t st_blksize;
    blkcnt_t st_blocks;
@};

int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
@end example

This syscalls return information about a file. No permissions are required
for fetching the file information, but they are required for the containing
directories.

@code{0} is returned on success, @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The passed path or file descriptor is not valid.

@item
@code{EFAULT}: The passed address for the path or stat buffer is not valid.
@end itemize

@node getcwd/chdir
@section getcwd/chdir

@example
char *getcwd(char *buf, size_t size);
int chdir(const char *path);
@end example

This syscalls manage the current working directory of the callee process.
@code{getcwd} will fetch it as an absolute path, while chdir will set it with
a C-style string.

@code{getcwd} returns a pointer to the string passed, or @code{NULL} if the
string is not big enough, including @code{NUL}, and sets the following errno:

@itemize @bullet
@item
@code{EINVAL}: The passed length is 0.

@item
@code{ERANGE}: The passed buffer + size is not big enough for the path, and it
is safe to reallocate and try again.

@item
@code{EFAULT}: The passed buffer has a bad address.
@end itemize

@code{chdir} returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed path points to a bad address.

@item
@code{ENAMETOOLONG}: The passed path is too long.

@item
@code{ENOTDIR}: The passed path is not a directory or has 0 length.
@end itemize

@node ioctl
@section ioctl

@example
int ioctl(int fd, unsigned long request, void *argument);
@end example

This syscall manipulates the underlying device parameters of special files. It
allows a device-dependent API for fetching and setting several modes.

@code{ioctl} returns @code{0} on success and @code{-1} on failure, and sets the
following errno:

@itemize @bullet
@item
@code{ENOTTY}: The passed file does not support the passed ioctl.

@item
@code{EBADF}: The passed file does not exist for the process.

@item
@code{EFAULT}: The passed argument is in non-accesible memory
@end itemize

@node sched_yield
@section sched_yield

@example
int sched_yield(void);
@end example

This syscall relinquishes execution of the caller thread.
Its up for the kernel how far in the queue of execution this thread will go.

This syscall returns @code{0} always, as it never fails, this is done for
compatibility with POSIX instead of having a @code{void} return type.

@node set_deadlines
@section set_deadlines

@example
int set_deadlines(int run_time, int period);
@end example

This syscalls sets the run time and period of the calling thread, the meaning
of this is explained in @xref{Scheduling and predictability}.

The units of both runtime and period are nanoseconds.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow the operation.
@item
@code{EINVAL}: Bad period or runtime make system not schedulable, or are
nonsensical.
@end itemize

@node dup/dup2/dup3
@section dup/dup2/dup3

@example
int dup(int oldfd);
int dup2(int oldfd, int newfd);
int dup3(int oldfd, int newfd, int flags);
@end example

This syscalls allocate new file descriptors pointing to the same file as the
passed file descriptor. @code{dup} chooses a descriptor itself, while
@code{dup2} and @code{dup3} will replace @code{newfd} with the new descriptor,
closing the old one if necessary.

The flags of the duplicated file descriptor are reset, this means
@code{O_CLOEXEC}, and other flags like @code{O_NONBLOCK} are not inherited. One
can use @code{dup3} to set those flags for the duplicated file descriptor using
the @code{flags} field.

All of these 3 syscalls return the new fd on success and @code{-1} on failure.
The errno codes set on failure are:

@itemize @bullet
@item
@code{EBADF}: The passed file descriptor is not owned by the process.

@item
@code{EMFILE}: Too many files have already been opened by the process.

@item
@code{EINVAL}: For @code{dup3}, @code{oldfd} and @code{newfd} are the same, or
flags are not @code{0} or @code{O_CLOEXEC}
@end itemize

@node access
@section access

@example
int access(const char *path, int mode);
@end example

This syscalls tests for file permissions and access without opening it.
@code{path} will be checked for a set of options or'd in @code{mode}, the
options are:

@itemize @bullet
@item
@code{F_OK (0b0001)}: The existance of the file is checked.

@item
@code{R_OK (0b0010)}: Being able to read the file is checked.

@item
@code{W_OK (0b0100)}: Being able to write to the file is checked.

@item
@code{X_OK (0b1000)}: The file being executable is checked.
@end itemize

The syscall returns @code{0} on success of checking the passed conditions
and @code{-1} on failure. The errno codes set on failure are:

@itemize @bullet
@item
@code{EFAULT}: The passed path points to invalid memory.

@item
@code{EINVAL}: The passed @code{mode} is not valid.

@item
@code{ENOENT}: The requested path to check does not exist.
@end itemize

@node thread_sched
@section thread_sched

@example
int get_thread_sched(void);
int set_thread_sched(int flags);
@end example

This syscalls manage scheduling properties of the callee thread. Both functions
operate on a bitmap with the following bits

@itemize @bullet
@item
@code{THREAD_MONO (0b1)}: Marks whether the thread is a monothread, see
@xref{Scheduling and predictability} for details.
@end itemize

@code{get_thread_sched} returns the flags and does not fail, @code{set_thread_sched}
returns @code{0} on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow the operation.
@end itemize

@node fcntl
@section fcntl

@example
int fcntl(int fd, int cmd, int arg);
@end example

This syscall is a multiplexed syscall that performs the operations described
below on the open file descriptor @code{fd}. The operation is determined by
@code{cmd} and may take an optional argument @code{arg}.

The syscall's return value will depend on the requested @code{cmd}, and is
detailed along the operations below.

The valid operations are:

@itemize @bullet
@item
@code{F_GETFD (3)}: The flags used for @code{fd} will be returned, right now
only @code{FD_CLOEXEC} is supported. The syscall will return the flags on
success.

@item
@code{F_SETFD (4)}: The flags for @code{fd} will be set with @code{arg}. The
syscall will return @code{0} on sucess.
@end itemize

On failure, the syscall returns @code{-1}. The returned @code{errno} are:

@itemize @bullet
@item
@code{EINVAL}: The passed @code{cmd} is not implemented by the kernel.

@item
@code{EBADF}: The passed @code{fd} is not open.
@end itemize

@node spawn
@section spawn

@example
pid_t spawn(const char *path, char *const argv[], char *const envp[]);
@end example

This syscall creates a new process and executes the program located at
@code{path}, passing it @code{argv} and @code{envp}. The new process inherits
nothing from the parent except duplicating its @code{stdin}, @code{stdout}, and
@code{stderr} for itself.

@code{spawn} is intended as a replacement for the @code{fork}/@code{exec}
idiom, while requiring no MMU support or intermediary address space copies,
making it more portable and faster.

The syscall returns the pid of the created process or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file pointed by @code{path} does not exist.

@item
@code{EAGAIN}: The process could not be created, please try again later.

@item
@code{EACCES}: The file couldn't be launched out of a permission error, or
MAC did not allow it.
@end itemize

@node getrandom
@section getrandom

@example
ssize_t getrandom(void *buffer, size_t length);
@end example

This syscall fills the buffer pointed to @code{buffer} with up to @code{length}
random bytes. These bytes can be used for cryptographic purposes.

The operation is the same as reading from @code{/dev/random}. It is provided
instead of just reading from the device as to avoid denial of service attacks
based on exhausting the file descriptor limit of the system, along with other
vulnerabilities and inconveniences related to the classic file interface.

The syscall returns the count of read random data or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{buffer} points to invalid memory.
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node mprotect
@section mprotect

@example
int mprotect(void *addr, size_t len, int prot);
@end example

This syscall allows to change the permission of a range of memory of the passed
length pointed by @code{addr}, previously mapped by the caller. The format of
@code{prot} is the same as @code{mmap}.

@code{addr} and @code{len} must be aligned to an architecture-valid alignment.

The syscall returns the @code{0} on success or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{addr} points to invalid memory.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node crypto_request
@section crypto_request

@example
int crypto_request(unsigned long request, void *argument);
@end example

This syscall exposes kernel cryptographic facilities on the same way
@code{ioctl} does for the @code{/dev/crypto} pseudo-device in OpenBSD systems.
A series of authentication and encryption algorithms are supported.

All the modes available and their @code{argument} are:

@table @code
@item CRYPTO_AES128_ECB_ENCRYPT (0)
@itemx CRYPTO_AES128_ECB_DECRYPT (1)
@itemx CRYPTO_AES128_CBC_ENCRYPT (2)
@itemx CRYPTO_AES128_CBC_DECRYPT (3)
@itemx CRYPTO_AES128_CTR_CRYPT (4)

When using these encryption algorithms, @code{argument} points to a structure
with the form:
@example
struct crypto_aes_data @{
   __uint128_t  key;    // Key for the AES encryption.
   __uint128_t  iv;     // Initialization vector/nonce when needed.
   void        *data;   // Data pointer.
   uint32_t     length; // Length, must be a multiple of 16.
@}
@end example

These request will encrypt or decrypt @code{length} bytes of data in-place
pointed by @code{data}, @code{length} must be divisible by 16 (128-bit blocks).
@end table

Note CTR operation modes have the same encryption and decryption procedure, so
only a single @code{CRYPT} option is exposed. When doing CTR, the IV will be
used as a 96-bit nonce as well.

The syscall returns @code{0} on success, or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{argument} points to invalid memory.

@item
@code{ENOSYS}: @code{request} is not implemented by the hardware.
@end itemize

@node set_mac_capabilities
@section set_mac_capabilities

@example
#define MAC_EXIT_ITSELF   0b000001
#define MAC_CREATE_OTHERS 0b000010
#define MAC_CHANGE_SCHED  0b000100
#define MAC_ACC_ENTROPY   0b001000
#define MAC_ALLOC_MEM     0b010000
#define MAC_DEALLOC_MEM   0b100000

int set_mac_capabilities(unsigned long request);
@end example

This syscall sets MAC filters on the way described in
@ref{Mandatory access control}.

This syscall always returns @code{0} and does not fail, settings will just
be ignored if permission to change them is not granted.

@node lock_mac
@section lock_mac

@example
int lock_mac(void);
@end example

This syscall locks MAC modification as described in
@ref{Mandatory access control}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC was already locked.
@end itemize

@node add_mac_filter
@section add_mac_filter

@example
#define MAC_FILTER_INC_FILES 0b0000001
#define MAC_FILTER_INC_DIRS  0b0000010
#define MAC_FILTER_R         0b0000100
#define MAC_FILTER_W         0b0001000
#define MAC_FILTER_EXEC      0b0010000

struct mac_filter @{
    char     path[75];
    int      length;
    uint32_t perms;
@};

int add_mac_filter(struct mac_filter *filter);
@end example

This syscall adds file-based filters as described in
@ref{Mandatory access control}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed pointer does not point to valid memory.
@item
@code{EAGAIN}: The system has reached a limit on registered rules.
@item
@code{EINVAL}: The passed rule is already covered or conflicts with an existent
one.
@end itemize

@node set_mac_enforcement
@section set_mac_enforcement

@example
#define MAC_DENY            0b001
#define MAC_DENY_AND_SCREAM 0b010
#define MAC_KILL            0b100

int set_mac_enforcement(unsigned long request);
@end example

This syscall sets the action to take for enforcement on MAC issues as explained
in @ref{Mandatory access control}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC was locked.
@end itemize

@node Devices and their properties
@chapter Devices and their properties

Ironclad exposes a number of devices, physical and virtual, to userland. All
of them are exposed under the @code{/dev} location, and support a series of
standard operations, like being manipulated by the usual file-related
syscalls like @code{read} or @code{write}, while sporting device-specific
interfaces in the form of device-specific @code{ioctl} requests.

The devices detailed in this chapter are divided in "Common devices", which
are devices featured regardless of the architecture running Ironclad, and
architecture-specific devices.

@node Common devices
@section Common devices

@subsection debug

@code{/dev/debug} wraps architecture-specific debug output channels for use
with file operations. For x86-based targets, this is QEMU's E9, for arm-based
and sparc-based targets, this is UART.

@subsection ramdev

The devices starting by @code{ramdev} are virtual devices representing the
RAM driver passed by some boot protocols, an FS can be mounted to them, usually
USTAR. These RAM devices are exclusively read-only.

@subsection random

The device @code{random} is equivalent to the one featured in other unix-like
kernels. Keep in mind that Ironclad has limited sources of entropy, so the
quality of this random numbers is a bit limited. Writing to the source is not
allowed, unlike other systems.

@code{/dev/urandom} does the same as @code{/dev/random}, and is only provided
for compatibility.

@code{getrandom} is provided as well for avoiding the file interface.

@subsection null/zero

@code{null} and @code{zero} are the equivalent of the @code{null} and
@code{zero} devices for platforms like Linux.

@code{null} returns @code{EOF} whenever read, and all the write operations are
discarded.

@code{zero} returns exclusively a stream of zeros when read, and all write
operations are discarded.

@subsection rtc

@code{/dev/rtc} exposes the hardware RTC in an architecture independent manner.

The device only allows the following @code{ioctl} operations.

The time structures handled represent ready-to-use, calendar timestamps.

@example
RTC_RD_TIME  = 1 // Reads time to the passed structure.
RTC_SET_TIME = 2 // Sets the RTC to the passed time.
struct rtc_time @{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;     /* unused */
    int tm_yday;     /* unused */
    int tm_isdst;    /* unused */
@};

ioctl(rtc, ..., pointer_to_rtc_time)
@end example

@node aarch64-stivale2 devices
@section aarch64-stivale2 devices

@subsection pl011

The device @code{pl011} supports read operations for PL011 UART compatible
devices.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented, only the ones related to input stream
settings.

The default baud for the device is set to be @code{115200}.

@node sparc-leon3 devices
@section sparc-leon3 devices

This target has no special devices.

@node x86_64-multiboot2 devices
@section x86_64-multiboot2 devices

@subsection bootfb

The @code{bootfb} device exposes the framebuffer passed as part of the
boot-protocol, when present. The device is not accessible by normal @code{read}
and @code{write} calls, and must be @code{mmap}'d for operating on it.

The @code{bootfb} device has a special @code{ioctl} call, which has an
argument with the following structure:

@example
FB_DIMENSIONS = 1
struct fb_dimensions @{
   uint32_t width;
   uint32_t height;
   uint32_t pitch;
   uint8_t  bpp;
@};

ioctl(fb, FB_DIMENTIONS, pointer_to_fb_dimensions)
@end example

@subsection ps2keyboard/ps2mouse

The devices @code{ps2keyboard} and @code{ps2mouse} exposes x86's native PS2
interfaces, @code{ps2keyboard} is a normal character device, while
@code{ps2mouse} is a character device that returns mouse packets under the
structure:

@example
struct mouse_data @{
   uint32_t x_variation;
   uint32_t y_variation;
   uint8_t  is_left_click;
   uint8_t  is_right_click;
@};
@end example

@code{ps2mouse} supports a series of @code{ioctl} calls for setting different
modes and talking directly with the PS2 controller:

@example
PS2MOUSE_2_1_SCALING     = 1
PS2MOUSE_1_1_SCALING     = 2
PS2MOUSE_SET_RES         = 3
PS2MOUSE_SET_SAMPLE_RATE = 4

ioctl(mouse, PS2MOUSE_2_1_SCALING, ignored);  // Enable 2:1 scaling.
ioctl(mouse, PS2MOUSE_1_1_SCALING, ignored);  // Enable 1:1 scaling.
ioctl(mouse, PS2MOUSE_SET_RES, resolution);   // Set resolution (0 - 3).
ioctl(mouse, PS2MOUSE_SET_SAMPLE_RATE, rate); // Set sample rate (0 - 200).
@end example

Valid resolutions and sample rates are values for the PS2 controller, else
the call is ignored. For valid values and their meaning refer to
@uref{https://isdaman.com/alsos/hardware/mouse/ps2interface.htm, this website}.

@subsection serial

The devices starting by @code{serial} represent the several character devices
used for each present serial port, they support read/write operations, but no
TTY interface is exposed, they are raw byte streams.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented as the serial devices are not ttys but
just byte streams.

The default baud for all ports is set to be @code{115200}.

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texi

@bye
