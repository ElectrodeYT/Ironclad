\input texinfo
@setfilename ironclad.info
@documentencoding UTF-8
@settitle Kernel interfaces

@copying
Copyright @copyright{} 2023 streaksu

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@title Ironclad kernel and userland interface
@subtitle Methods to interface with the kernel from boot-time and userland.
@author streaksu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents

@ifnottex
@node Top
@top Ironclad

This manual documents interfaces and devices Ironclad exposes, without having
to navigate the often cryptic and scary Ada code.

@insertcopying
@end ifnottex

@menu
* Introduction::                       Project overview and bug reporting.
* Boot-time command-line options::     Command-line options.
* Scheduling and RTC::                 Scheduling methodology and features.
* Memory allocation algorithms::       The available allocation algorithms.
* Userland state and conditions::      Userland state and conditions.
* Security and integrity facilities::  Ironclad-specific security facilities.
* Syscalls::                           Listings and explanation of syscalls.
* Filesystems support and interfaces:: Filesystems supported by the kernel.
* Devices and their properties::       Devices exposed by the kernel.
* GNU Free Documentation License::     Copying and sharing this manual.

@detailmenu
--- The Detailed Node Listing ---

Introduction

* How to contribute::    How to contribute code to the kernel.
* Error reporting::      How to report issues with the kernel.
* Formal verification::  Current state of the formal verification effort.

Boot-time command-line options

* Format::                 Description of the format.
* List::                   List of all the available cmdline arguments.

Scheduling and RTC

* Ticks and other interruptions::      Thread interruptions to expect.
* Scheduling and predictability::      Scheduling in Ironclad in depth.
* Anti-Starvation Corrections (ASC)::  Uses and consequences of enabling ASC.

Memory allocation algorithms

* standard::   The standard allocator.
* alloconly::  The low profile allocator that does not free.

Userland state and conditions

* Program loading::  Format of the loaded programs.
* Memory layout::    Layout of memory in userland.

Security and integrity facilities

* Users and groups::                UIDs, EUIDs, GIDs, and all the fuzz.
* Mandatory access control (MAC)::  MAC quickguide and configuration.
* Integrity checks::                Userland integrity checks.

Syscalls

* x86_64::                  x86_64 syscall ABI and table.
* Errno::                   Error conditions and their values.
* exit::                    Exit the callee process.
* arch_prctl::              Interacting with architectural thread-local data.
* open::                    Opening file-system entities.
* close::                   Closing file descriptors.
* read/write::              Read and write from file descriptors.
* seek::                    Modify and fetch file offsets.
* mmap/munmap::             Manage memory regions.
* getpid/getppid::          Get the PIDs of the caller.
* exec::                    Launching new programs.
* clone::                   Create new processes and threads.
* wait::                    Waiting for execution of a child to finish.
* uname::                   Fetch basic system information.
* sethostname::             Hostname setting.
* unlink::                  Queue files for deletion.
* fstat::                   Fetch file information.
* getcwd/chdir::            Current working directory manipulation.
* ioctl::                   IO multiplexer.
* sched_yield::             Relinquish CPU time.
* set_deadlines::           Manage scheduler deadlines.
* pipe::                    Create pipes.
* rename::                  Rename a file.
* sysconf::                 Fetch general system parameters and information.
* spawn::                   Fork+exec power incarnate.
* thread_sched::            Manage scheduler-related thread permissions.
* fcntl::                   Multiplexed operations for files.
* exit_thread::             Exit the calling thread.
* getrandom::               Bypass /dev/random for avoiding DoS attacks.
* mprotect::                Change memory permissions.
* mac_capabilities::        Get and set MAC capabilities.
* add_mac_permissions::     Configure MAC using filesystem-based filters.
* set_mac_enforcement::     Set enforcement to follow on MAC violations.
* mount::                   Mount partitions.
* umount::                  Unmount partitions.
* readlink::                Read the contents of a symlink.
* getdents::                Get directory entries.
* sync::                    Synchronize device caches.
* mknod::                   Create several kinds of files.
* truncate::                Truncate the contents of a file to an offset.
* mkdir::                   Create directories.
* symlink::                 Create symbolic links.
* integrity_setup::         Setup and configure integrity checks.
* openpty::                 Create pseudoterminals.
* fsync::                   Synchronize file-specific caches.
* link::                    Create hard links.
* ptrace::                  Trace and debug children processes.
* poll::                    I/O event multiplexer.
* getuid/geteuid::          Get the UID and the effective UID.
* setuids::                 Set the UID and the effective UID.
* fchmod::                  Change the mode of a file descriptor.
* umask::                   Get and set the calling process umask.
* reboot::                  Machine power management.
* fchown::                  Change ownership of a file descriptor.
* pread/pwrite::            Atomic read and write from file descriptors.

Filesystems support and interfaces

* Extended FileSystem::    EXT-series filesystems (ext2, ext3, ext4).
* File Allocation Table::  FAT-series filesystems.

Devices and their properties

* Common devices::             Devices common to all architectures and targets.
* aarch64-stivale2 devices::   Devices specific to aarch64-stivale2.
* arm-raspi2b devices::        Devices specific to arm-raspi2b.
* sparc-leon3 devices::        Devices specific to sparc-leon3.
* x86_64-multiboot2 devices::  Devices specific to x86_64-multiboot2.

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

Ironclad is a partially formally verified real-time kernel, with a small
footprint, for general-purpose and embedded OSes, written in SPARK and Ada.

Some of the supported features are:
@itemize
@item
A familiar POSIX-compatible interface
@item
True simultaneous multitasking
@item
Complex virtual and physical memory support, VFS support
@item
Resiliency and small footprint
@item
Partial gold-level formal verification
@item
Advanced cryptography and a security-centered architecture
@item
Hard real-time scheduling and real-time oriented features
@end itemize

This manual is a work in progress: many sections make no attempt to
explain basic concepts in a way suitable for novices. Thus, if you are
interested, please get involved in improving this manual.

@node How to contribute
@section How to contribute

Thanks for considering contributing to Ironclad, it means a lot.

There are several ways one can help the Ironclad project, from writing and
correcting documentation to contributing source.

For submitting patches, be it for Ironclad's webpages, kernel code, or
documentation, please submit the patch to the project's
@url{https://savannah.nongnu.org/patch/?group=ironclad, patch manager},
(@url{https://savannah.nongnu.org/patch/?group=ironclad&func=additem, create an item}).

If prefered, one can send a patch in
@email{bug-ironclad@@nongnu.org, bug-ironclad}.

When contributing code, it's good to keep in mind these guidelines:

@enumerate
@item
One may only contribute code that complies with the project's license, or code
ruled by GPL-compatible licenses under certain conditions, its the
responsability of the contributor to ensure this is the case.

@item
Add license headers and detail the authors of the code. For files with a main
author and small touches being done on top of it, you can update the authors in
the copyright to `Copyright (C) 2022 [main author's name], et. al.`, or add
your name or pseudonym for a major contribution to the comma-separated list.

@item
It goes a long way to add the relevant documentation as comments and standalone
documentation. You can end up saving others a lot of time!
@end enumerate

@node Error reporting
@section Error reporting

Ironclad is a fairly new project at the end of the day, so things are prone to
fail. Once an issue arises, one can open a bug report at the
@url{https://savannah.nongnu.org/bugs/?group=ironclad, project's bug tracker},
(@url{https://savannah.nongnu.org/bugs/?group=ironclad&func=additem, create an item}).

@node Formal verification
@section Formal verification

Ironclad is in an ongoing process to raise its verification
level to @url{https://docs.adacore.com/spark2014-docs/html/ug/en/usage_scenarios.html#levels-of-spark-use, a mix of silver and gold level} for
as many of the kernel facilities as possible.

This is done with the goal of ensure the absence of errors in a crucial system
component like the kernel, and for ensuring the suitability of Ironclad for
embedded and mission critical tasks.

@node Boot-time command-line options
@chapter Boot-time command-line options

Ironclad takes, as part of its boot protocol, a series of options and values.
The parsing of this options is architecture and platform independent, while the
ability to modify said options and values is entirely up to the platform and
bootloader.

@node Format
@section Format

The format is a list of keys that can have arguments or not in a C-style
NUL-terminted string, as such:

@example
key1=value1 key2 key3=value3 ... keyN
@end example

@node List
@section List

This are the keys and values the kernel takes, and under which circumstances:

@table @code
@item root=<device>
Device to mount as root, if any.

@item init=<path>
Path to a program that will be booted by the kernel when finished loading.
The program will be started with @code{stdin} set to @code{/dev/null}, and
@code{stdout} and @code{stderr} set to @code{/dev/debug}.

@item noprogaslr
The offset of loaded programs in virtual memory is randomized when loading if
possible, this option disables it system-wide at boot time and hardcodes it to
the lowest available value.

@item nolocaslr
The same as @code{noprogaslr} but applied to memory locations like stacks
and memory allocation.
@end table

@node Scheduling and RTC
@chapter Scheduling and RTC

Ironclad is built around hard real-time work, this chapter explains how that
is accomplished along with how scheduling works, predictability of it, and
other useful related features.

@node Ticks and other interruptions
@section Ticks and other interruptions

Ironclad will not interrupt a running thread for timers or heartbeats, if
necessary, at the expense of performance by, for example, using polling instead
of interrupt-based operation for device drivers.

A thread, however, may be interrupted for task-switching, which is needed for
scheduling to work. This will not be an issue for most operations, but if the
user desires absolutely 0 interruptions and/or jitter, one can use
@code{THREAD_MONO}, explained at @pxref{Scheduling and predictability}.

@node Scheduling and predictability
@section Scheduling and predictability

Scheduling in Ironclad is done using Rate-Monotonic Scheduling (RMS).

RMS is an optimal fixed-priority policy where the higher the frequency of a
task, the higher is its priority. This approach allows Ironclad to provide
scheduling guarantees for hard real time applications.

@subsection Predictability and guarantees

The sequence of scheduled tasks is fully predictable. Once priorities are
assigned using RMS, higher priority threads will interrupt lower priority
threads according to their periods, specified using @pxref{set_deadlines}.

Thanks to RMS, deadlines are mathematically guaranteed to be met as long as an
upper bound of CPU time utilization is not exceeded. Said bound can be
calculated using the number of tasks following the schedulability test:

@displaymath
\sum_{i=1}^{n}{U_i}=\sum_{i=1}^{n}{C_i \over T_i}\leq n([2^{1/n}]-1)
@end displaymath

Where:

@table @math
@item U_i
CPU time utilization of a thread.
@item C_i
CPU time needed by the thread.
@item T_i
Period of the thread.
@item n
Number of threads to be scheduled.
@end table

When the number of threads tends to infinity, the condition tends to:

@displaymath
\lim_{n\rightarrow\infty}n([2^{1/n}]-1)=\ln 2\approx 0.693147\ldots
@end displaymath

The kernel will just always compare with this approximated value for
simplicity and due to floating-point limitations. If this quick test is not
passed, the kernel will warn about it, but will not refuse to schedule, since
the user might know better, or may not want to respect deadlines at all.

Since the kernel leaves the responsability (and priviledge) of ensuring a
correct scheduling setup to the user, this opens the door to a number of tricks
to break through the 69% usage ceiling, while keeping deadlines alive and well.

@table @code
@item Harmonic chains and task periods
Thanks to the @url{https://ieeexplore.ieee.org/document/160369, work of Kuo and Mok},
we know that for harmonic sets of tasks, the schedulability test becomes:

@displaymath
\sum_{i=1}^{n}{U_i}=\sum_{i=1}^{n}{C_i \over T_i}\leq K([2^{1/K}]-1)
@end displaymath

Where @math{K} is the number of harmonic sets, for @math{1}, the utilization
becomes 100%.

A harmonic set of tasks is the set where every task evenly divides the period
of every longer period. For example, a harmonic set of 3 tasks periods is
@code{@{20, 60, 120@}}
@end table

@subsection Monothreading

Scheduling in Ironclad supports creating critical sections backed by the kernel
using @pxref{thread_sched} and @code{THREAD_MONO}. This feature can be thought
of as optional cooperative scheduling.

The flag will make the scheduler not preemt at all from the thread until
requested. A task switch can be requested using @xref{sched_yield} or
relinquishing execution in any other similar way. Doing that will not reset the
flag, but it will allow the system to search for another thread.

@node Anti-Starvation Corrections (ASC)
@section Anti-Starvation Corrections (ASC)

Due to the nature of hard real-time and some design decisions, userland is
vulnerable to deadlocks and other starvation issues if priorities are not
set carefully. For avoiding this, ASC is available for use, which implements
some basic ageing of thread priorities when not scheduled for a while, among
others.

This feature may in turn effectively make Ironclad not hard real-time, in the
meaning that deadlines may be not respected, but that is the price to pay for
avoiding starvation.

These measures can be easily enabled or disabled at build time, and only affect
the scheduler, the rest of the system will work out as defined in the rest of
the document regardless of choice.

@node Memory allocation algorithms
@chapter Memory allocation algorithms

Ironclad features several memory allocator choices for use, the chosen
allocator will be used both for kernel and userland allocations.

@node standard
@section standard

The standard allocator is a general purpose allocator for your average
everyday allocator needs. Its internally implemented as a bitmap allocator with
page-sized blocks and a quick cache for small objects.

For more specialized uses, other allocators are bound to do better, but this
one is a safe bet.

@node alloconly
@section alloconly

The 'alloconly' allocator is faster and uses way less memory than the standard
allocator, while not being able to free as its biggest trade-off. It is
internally implemented as a singly linked list of bump allocators.

This allocator is appropiate for embedded applications that are recommended
to allocate all the program will ever need at the beggining of its execution,
or for debugging memory management, as its a much simpler allocator than the
standard option.

@node Userland state and conditions
@chapter Userland state and conditions

Ironclad places several requirements on loaded userland programs, from the
format of which, to memory layout.

@node Program loading
@section Program loading

Loaded programs must be under the ELF64 format, other formats may be supported
in the future. Loaded programs can be static or relocatable.

@code{ld.so}, or any other linker program detailed on the interpreter segment
of the ELF executable will be a special case, it is assumed to be relocatable.

There is support for GNU stack program headers.

@node Memory layout
@section Memory layout

Loaded programs are loaded at address 0, and they are free to allocate
themselves at nearby offsets.

@code{ld.so} and entities like stacks, anonymous memory regions, and others,
will be randomized on load time following
@uref{https://en.wikipedia.org/wiki/Address_space_layout_randomization, ASLR},
and must not be relied upon. It is up to @code{ld.so} to optionally place
additionally loaded libraries at random offsets.

@node Security and integrity facilities
@chapter Security and integrity facilities

This chapter digs into the various Ironclad-specific security and integrity
features available for the user.

@node Users and groups
@section Users and groups

As part of the UNIX-like package, Ironclad supports the traditional UID/EUID
values per-process for basic access protection, both for files and syscalls.

Unlike most UNIX systems, the @code{setuid} bit is fully ignored and not
implemented, instead, as part of the mandatory access control facilities
explained later, @code{MAC_CAP_SETUID} is provided, with similar functionality.

Groups are not supported in any shape or form.

@node Mandatory access control (MAC)
@section Mandatory access control (MAC)

Mandatory access control (MAC) is one of the main components of Ironclad
security. It does not necesarily help with preventing breaches of security, but
minimizes the things a breached process can do, when configured correctly.

MAC in Ironclad consists on a series of settings inherited from process to
process, with only more restrictive priviledge escalations allowed, with
configurable actions to take on triggering illegal actions. These settings come
in the form of capabilities and file filters.

Capabilities are a set of coarse permissions that restrict a process on what it
can and cannot do, they are configured using @ref{mac_capabilities}.

The available capability list is:

@table @code
@item MAC_CAP_SCHED
The process will be allowed to change its own scheduling rules, like modifying
deadlines.

@item MAC_CAP_SPAWN
The process will be allowed to spawn other processes and threads.

@item MAC_CAP_ENTROPY
The process will have unrestricted access to the sources of entropy of the
kernel, this does not cover the UNIX-standard @code{random/urandom}.

@item MAC_CAP_SYS_MEM
The process will be able to allocate and deallocate both private and shared
memory regions.

@item MAC_CAP_USE_NET
The process will be able to use networking.

@item MAC_CAP_SYS_NET
The process will be able to modify networking, for things like hostname
changing.

@item MAC_CAP_SYS_MNT
The process will be able to modify, add, and remove mountpoints.

@item MAC_CAP_SYS_PWR
The process will be able to modify power settings, along doing things like
shutdown and reboot.

@item MAC_CAP_PTRACE
The process will be able to use ptrace on children processes.

@item MAC_CAP_SETUID
The process will be able to change its effective and global UIDs without
checks.

@item MAC_CAP_SYS_MAC
The process will be able to add allowed inodes to the MAC definitions.
@end table

Apart of capabilities, access to filesystem structures and permission
management can be done using @ref{add_mac_permissions}.

The method of acting on MAC violations and failures can be set by using
@ref{set_mac_enforcement}. Possible values include denying requests, killing
the offending part outright, or denying and additionally logging the event.

Once booted, MAC is enabled and gives full access to everything, effectively
being transparent, its up to the root user to further restrict it.

@node Integrity checks
@section Integrity checks

Ironclad provides facilities for running configurable userland-wide checks
configurable using the @code{integrity_setup} system call.

Both in-demand and interrupt-based solutions are provided. The in-demand
solution is triggered by direct syscall use, it has the advantage of being
interrupt-free, which makes runtime analysis and realtime overall much easier.
The interrupt-driven kernel one offers convenience and being independent
from userland altogether. When using the interrupt-based kernel solution,
watchdog hardware may be used internally.

@node Syscalls
@chapter Syscalls

Syscalls in Ironclad have an architecture-dependent ABI, here is a list of the
supported architectures and the ABI for each of them.

@node x86_64
@section x86_64

Syscalls are invoked in Ironclad by triggering an interrupt to vector
@code{0x80}.

The index of the syscall is passed on @code{%rax}, while the return value is
returned on @code{%rax}, errno is returned on @code{%rdx}, arguments are passed
over @code{%rdi}, @code{%rsi}, @code{%rdx}, @code{%rcx}, @code{%r8},
@code{%r9}, and @code{%r10}, following the SysV ABI.

The list of syscalls ordered by their index in @code{rax} for the platform is:

@enumerate 0
@item
@xref{exit}.
@item
@xref{arch_prctl}.
@item
@xref{open, open}.
@item
@xref{close, close}.
@item
@xref{read/write, read}.
@item
@xref{read/write, write}.
@item
@xref{seek}.
@item
@xref{mmap/munmap, mmap}.
@item
@xref{mmap/munmap, munmap}.
@item
@xref{getpid/getppid, getpid}.
@item
@xref{getpid/getppid, getppid}.
@item
@xref{exec}.
@item
@xref{clone}.
@item
@xref{wait}.
@item
@xref{uname}.
@item
@xref{sethostname}.
@item
@xref{unlink}
@item
@pxref{fstat, fstat}.
@item
@xref{getcwd/chdir, getcwd}.
@item
@xref{getcwd/chdir, chdir}.
@item
@xref{ioctl}.
@item
@xref{sched_yield}.
@item
@xref{set_deadlines}.
@item
@xref{pipe}.
@item
@xref{getuid/geteuid, getuid}.
@item
@xref{rename}.
@item
@xref{sysconf}.
@item
@xref{spawn}.
@item
@xref{thread_sched, get_thread_sched}.
@item
@xref{thread_sched, set_thread_sched}.
@item
@xref{fcntl}.
@item
@xref{exit_thread}.
@item
@xref{getrandom}.
@item
@xref{mprotect}.
@item
@xref{sync}
@item
@xref{mac_capabilities, set_mac_capabilities}.
@item
@xref{mac_capabilities, get_mac_capabilities}.
@item
@xref{add_mac_permissions}.
@item
@xref{set_mac_enforcement}
@item
@xref{mount}.
@item
@xref{umount}.
@item
@xref{readlink}.
@item
@xref{getdents}.
@item
@xref{mknod}.
@item
@xref{truncate}.
@item
Unused.
@item
@xref{symlink}.
@item
@xref{integrity_setup}.
@item
@xref{openpty}.
@item
@xref{fsync}.
@item
@xref{link}.
@item
@xref{ptrace}
@item
@xref{poll}
@item
@xref{getuid/geteuid, geteuid}.
@item
@xref{setuids}
@item
@xref{fchmod}
@item
@xref{umask}
@item
@xref{reboot}
@item
@xref{fchown}
@item
@xref{pread/pwrite, pread}.
@item
@xref{pread/pwrite, pwrite}.
@end enumerate

@node Errno
@section Errno

Errno are values returned by the kernel to detail the nature of an error in
depth. When a syscall does not error out, it returns the value 0 on the errno
field. Here is a table of all the possible errno and its values and meaning:

@table @code
@item ENOERR (0)
There was no error, this is displayed for completeness.

@item ERANGE (3)
The passed value was not big enough.

@item EACCES (1002)
The passed access for a variable points to bad memory.

@item EAGAIN (1006)
The requested resource is not available at the moment.

@item EBUSY (1010)
The requested resource is busy and cannot handle the request.

@item ECHILD (1012)
The passed value is not a child process.

@item EFAULT (1020)
The passed value would make the program fault.

@item EINVAL (1026)
The passed value is not valid for the called syscall.

@item EIO (1027)
The requested operation failed at a device level.

@item EMFILE (1031)
Too many files were opened by the process.

@item ENAMETOOLONG (1036)
The passed value is too big for the syscall.

@item ENOENT (1043)
No such file or directory.

@item ENOSYS (1051)
The requested syscall or flag is not implemented.

@item ENOTTY (1058)
The passed argument is not a TTY.

@item EPERM (1063)
Bad permissions.

@item ESPIPE (1069)
A seek was issued to an invalid device.

@item ESRCH (1070)
The passed item could not be found after a search.

@item EBADFD (1081)
The passed FD is in a bad state or invalid.

@end table

@node exit
@section exit

@example
void exit(uint64_t status);
@end example

This syscall terminates the calling process "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this, rookie mistake.
@end itemize

@node arch_prctl
@section arch_prctl

@example
int arch_prctl(int code, uint64_t argument);
@end example

This syscall interacts with architecture-specific thread-local storage. For
x86_64, these are the available codes:

@table @code
@item ARCH_SET_FS (1)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_FS (2)
Stores the current thread's FS into the variable pointed to by @code{argument}.

@item ARCH_SET_GS (3)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_GS (4)
Stores the current thread's GS into the variable pointed to by @code{argument}.
@end table

This syscall returns @code{0} on success, and @code{-1} on failure.
errno is to be set to the following values on failure:

@itemize @bullet
@item
@code{EINVAL}: @code{code} is not valid.

@item
@code{EFAULT}: @code{argument} is outside the available address space.
@end itemize

@node open
@section open

@example
int open(int dir_fd, char *path, int path_len, int flags);
@end example

@code{open} opens the passed file relative to @code{dir_fd}, depending on the
flags passed. It does not create the file if not existent. By default, the file
descriptor will remain open accross an @code{exec}.

@code{flags} can be an OR'd field of the following elements:

@table @code
@item O_RDONLY (0b000001)
Makes the file able to be read.

@item O_WRONLY (0b000010)
Makes the file able to be written to.

@item O_APPEND (0b000100)
Makes the file be opened at the end of the file, instead of the beggining.

@item O_CLOEXEC (0b001000)
Will make the file close when @code{exec}'d.

@item O_NOFOLLOW (0b0100000000)
Do not follow symlinks when opening the file.

@item O_NONBLOCK (0b1000000000)
Make the file not block on read or write operations when possible.
@end table

The syscall returns the opened file descriptor or @code{-1} on error, and errno
is set to the following:

@itemize @bullet
@item
@code{ENOENT}: The referenced file does not exist.

@item
@code{EINVAL}: Combination of @code{flags} is not valid.

@item
@code{EMFILE}: Too many files are already owned by the process.

@item
@code{EFAULT}: The passed path is outside the available address space.
@end itemize

@node close
@section close

@example
int close(int fd);
@end example

@code{close} closes an open file descriptor. Once no open references exist of a
file descriptor, its resources are freed, and the file deleted if needed.

The syscall returns 0 on success and -1 in failure, and errno is set to:

@itemize @bullet
@item
@code{EBADF}: The passed file to @code{close} is not valid.
@end itemize

@node read/write
@section read/write

@example
ssize_t read(int fd, void *buffer, size_t count);
ssize_t write(int fd, void *buffer, size_t count);
@end example

These syscalls attempts to read or write up to passed count from the passed file descriptor.

On files that support seeking, the operation commences at the file offset, and
the file offset is incremented by the number of bytes read or written. If the
file offset is at or past the end of file, no bytes are read or written, and
the operation returns zero.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed fd is not suitable for the operation.

@item
@code{EIO}: The requested operation failed at the device level.
@end itemize

@node seek
@section seek

@example
off_t seek(int fd, off_t offset, int whence);
@end example

This syscall repositions the file offset of the passed file description to the
passed offset according to the directive whence as follows:

@itemize @bullet
@item
@code{SEEK_SET} (1): Set to the passed offset.

@code{SEEK_CUR} (2): Set to the current offset plus the passed offset.

@code{SEEK_END} (4): Set to the size of the file plus the passed offset.
@end itemize

This syscall returns the resulting offset, or @code{-1} on failure. errno is to
be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EINVAL}: The whence is malformed or the resulting offset would be invalid.

@item
@code{ESPIPE}: @code{seek} was called on a TTY or a pipe.
@end itemize

@node mmap/munmap
@section mmap/munmap

@example
void *mmap(void *hint, size_t length, int protection, int flags, int fd, off_t offset);
int munmap(void *address, size_t length);
@end example

@code{mmap} creates a new mapping in the virtual address space of the calling
process. An address can be passed, if it is @code{null}, then the kernel gets
to choose the address, else, it is taken as a hint about where to place the
mapping. If a section of the mapping overlaps an existing mapping, it will be
ignored.

@code{hint} and @code{length} are required to be aligned to page boundaries
for the running architecture, else it will fail.

@code{protection} and @code{flags} are a bitfield of the following flags:

@itemize @bullet
@item
@code{PROT_READ} (0b00001): Read permissions.

@item
@code{PROT_WRITE} (0b00010): Write permissions.

@item
@code{MAP_FIXED} (0b00100): Use hint as a hard requirement.

@item
@code{MAP_ANON} (0b01000): Mapping is not backed by any file.

@item
@code{MAP_WC} (0b10000): Map using write-combining when possible.
@end itemize

@code{munmap} will unmap a range for the virtual address space of the calling
process, this values must be the same as passed and returned by @code{mmap},
partial unmapping is allowed.

@code{mmap} returns a pointer to the allocated area, or @code{-1} on failure.
@code{munmap} returns @code{0} on success, @code{-1} on failure. Both functions
set the following errno:

@itemize @bullet
@item
@code{EINVAL}: Bad hints or parameters.

@item
@code{ENOMEM}: The operation could not be completed due to a lack of memory.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getpid/getppid
@section getpid/getppid

@example
int getpid();
int getppid();
@end example

@code{getpid} returns the process ID (PID) of the calling process.
@code{getppid} does the same but it returns the one of the parent, which is the
process that created the callee by a myriad of ways.

This functions are always successful.

@node exec
@section exec

@example
int exec(const char *path, int path_len, char *const argv[], int argv_len, char *const envp[], envp_len);
@end example

This syscall executes the program passed with the passed argv and evp, closing
all the threads of the callee process and putting a single one in place for
the new program. Other process-specific elements like file descriptors are
untouched.

This syscall only returns in failure with @code{-1} with the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file passed in path doesnt exist.

@item
@code{EACCES}: The file couldn't be launched out of a permission error.
@end itemize

@node clone
@section clone

@example
#define CLONE_PARENT 0b01
#define CLONE_THREAD 0b10

pid_t clone(void *callback, uint64_t arg, void *stack, int flags, void *tls);
@end example

This syscall creates a new thread or process depending on @code{flags}.
@code{flags} can be an OR'd combination of the following flags:

@itemize @bullet
@item
@code{CLONE_PARENT} (0b01): The process or thread will be a child of the parent
of the caller process, instead of the caller process itself.

@code{CLONE_THREAD} (0b10): If set, a thread will be created and added to the
parent process, if not set, a process will be created instead. The child
process will only have the callee thread cloned. The other threads, if any,
are not cloned.
@end itemize

This syscall returns @code{0} on success for the child, and the children PID or
TID to the parent, in failure, the parent gets @code{-1} with the following
errno:

@itemize @bullet
@item
@code{EAGAIN}: The system could not create the entity right now, try again
later.

@item
@code{EINVAL}: @code{CLONE_PARENT} is specified and the caller process has no
parent.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node wait
@section wait

@example
pid_t wait(pid_t pid, int *status, int options);
@end example

This syscall suspends execution until the passed pid exits, to then store the
exit code in @code{status}.

@code{wait} allows the option @code{WNOHANG(0b000010)} for non-blocking
waiting, if the process has not finished yet, @code{0} will be returned.

@code{pid} can be a PID the callee is a parent of, or @code{-1} to wait on all
the PIDs the callee has as children. @code{0}, which waits on all the children
of a process group, is not implemented yet.

This syscall returns the PID waited on or @code{-1} on failure, along with the
following errno:

@itemize @bullet
@item
@code{ECHILD}: The passed PID does not exist.

@item
@code{EINVAL}: The passed options are not correct or the passed PID is @code{0}
@end itemize

@node uname
@section uname

@example
struct utsname @{
    char sysname[65];  // Kernel name (e.g., "Ironclad")
    char nodename[65]; // Hostname of the machine.
    char release[65];  // Kernel release (e.g., "2.6.28")
    char version[65];  // Kernel configuration date for debug purposes.
    char machine[65];  // Hardware identifier (e.g., "x86")
@};

int uname(struct utsname *name);
@end example

This syscall reports kernel information, like version, name, and hostname.
It returns @code{0} on success, and @code{-1} on failure, with the only errno
being @code{EFAULT} if the passed pointer is in an invalid address.

@node sethostname
@section sethostname

@example
int sethostname(const char *buffer, size_t length);
@end example

This syscall sets the kernel hostname to the passed string. @code{0} is
returned on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed buffer points to an invalid address.

@item
@code{EINVAL}: The passed length is bigger than the kernel can handle or 0.

@item
@code{EACCES}: MAC did not allow this.
@end itemize

@node unlink
@section unlink

@example
int unlink(int dir_fd, const char *path, int path_len);
@end example

The syscall queues for deletion the file pointed to by @code{path}. If
@code{path} points to a directory, it must be empty.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{ENOENT}: @code{delete} points to a file not valid for deletion, if at all.
@end itemize

@node fstat
@section fstat

@example
struct stat @{
    dev_t st_dev;
    ino_t st_ino;
    mode_t st_mode;
    nlink_t st_nlink;
    uid_t st_uid;
    gid_t st_gid;
    dev_t st_rdev;
    off_t st_size;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    blksize_t st_blksize;
    blkcnt_t st_blocks;
@};

int fstat(int fd, struct stat *statbuf);
@end example

This syscalls return information about an already opened file.

@code{0} is returned on success, @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The passed path or file descriptor is not valid.

@item
@code{ENOENT}: The file pointed by @code{path} does not exist.

@item
@code{EFAULT}: The passed address for the path or stat buffer is not valid.
@end itemize

@node getcwd/chdir
@section getcwd/chdir

@example
char *getcwd(char *buf, size_t size);
int chdir(const char *path, int path_len);
@end example

This syscalls manage the current working directory of the callee process.
@code{getcwd} will fetch it as an absolute path, while chdir will set it with
a C-style string.

@code{getcwd} returns a pointer to the string passed, or @code{NULL} if the
string is not big enough, including @code{NUL}, and sets the following errno:

@itemize @bullet
@item
@code{EINVAL}: The passed length is 0.

@item
@code{ERANGE}: The passed buffer + size is not big enough for the path, and it
is safe to reallocate and try again.

@item
@code{EFAULT}: The passed buffer has a bad address.
@end itemize

@code{chdir} returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed path points to a bad address.

@item
@code{ENAMETOOLONG}: The passed path is too long.

@item
@code{ENOTDIR}: The passed path is not a directory or has 0 length.
@end itemize

@node ioctl
@section ioctl

@example
int ioctl(int fd, unsigned long request, void *argument);
@end example

This syscall manipulates the underlying device parameters of special files. It
allows a device-dependent API for fetching and setting several modes.

@code{ioctl} returns @code{0} on success and @code{-1} on failure, and sets the
following errno:

@itemize @bullet
@item
@code{ENOTTY}: The passed file does not support the passed ioctl.

@item
@code{EBADF}: The passed file does not exist for the process.

@item
@code{EFAULT}: The passed argument is in non-accesible memory
@end itemize

@node sched_yield
@section sched_yield

@example
int sched_yield(void);
@end example

This syscall relinquishes execution of the caller thread.
Its up for the kernel how far in the queue of execution this thread will go.

This syscall returns @code{0} always, as it never fails, this is done for
compatibility with POSIX instead of having a @code{void} return type.

@node set_deadlines
@section set_deadlines

@example
int set_deadlines(int run_time, int period);
@end example

This syscalls sets the run time and period of the calling thread, the meaning
of this is explained in @xref{Scheduling and predictability}.

The units of both runtime and period are microseconds.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow the operation.
@item
@code{EINVAL}: Bad period or runtime make system not schedulable, or are
nonsensical.
@end itemize

@node pipe
@section pipe

@example
int pipe(int pipefd[2], int flags);
@end example

This syscalls creates a pipe with the passed flags and returns the registered
file descriptors in @code{pipefd}. Index @code{0} is the reader end, @code{1}
is the writing one.

The only available flag for use is @code{O_NONBLOCK}.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{pipefd} points to bogus memory.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node rename
@section rename

@example
#define RENAME_NOREPLACE 1
int rename(int sourcedirfd, const char *sourcepath, size_t sourcelen,
       int targetirfd, const char *targetpath, size_t targetlen, int flags);
@end example

This syscalls renames a file in an atomic operation, it is only available in
between files in the same mountpoint. If @code{targetpath} exists, it will be
replaced, @code{RENAME_NOREPLACE} may be passed in @code{flags} for making the
call fail in said case instead of replacing silently.

The syscall return the new fd on success and @code{-1} on failure. The errno
codes set on failure are:

@itemize @bullet
@item
@code{EFAULT}: One of the passed values is outside addressable memory.

@item
@code{ENAMETOOLONG}: The passed path is too long.

@item
@code{EIO}: The operation could not be done out of an internal error.
@end itemize

@node sysconf
@section sysconf

@example
#define SC_PAGESIZE      1 // Page size of the system.
#define SC_OPEN_MAX      2 // Maximum amount of files per process.
#define SC_HOST_NAME_MAX 3 // Maximum length of hostnames.
#define SC_AVPHYS_PAGES  4 // Number of free physical pages.
#define SC_PHYS_PAGES    5 // Number of total available pages.
#define SC_NPROC_ONLN    6 // Number of processors active and used.
#define SC_TOTAL_PAGES   7 // Total amount of installed memory pages.
#define SC_LIST_PROCS    8 // List all processes of the system.
#define SC_LIST_MOUNTS   9 // List all mountpoints of the system.

long int sysconf(int request, uintptr_t addr, uintptr_t len);
@end example

This syscalls fetches the requested information in @code{request} and returns
it.

Depending on the request, @code{addr} and @code{len} may be used for
determining the address of a buffer and its length for reporting information
that doesn't fit on the usual return value. The options where they have meaning
are:

@itemize @bullet
@item
@code{SC_LIST_PROCS}: @code{addr} points to an array of items, and @code{len}
is the count of bytes reserved in the array. The items have the structure:

@example
struct procinfo @{
    char id[20];
    uint16_t id_len;
    uint16_t ppid;
    uint16_t pid;
    uint32_t flags;
@} __attribute__((packed));
@end example

The total number of processes is returned, even if it doesnt fit in the passed
array.

@item
@code{SC_LIST_MOUNTS}: @code{addr} points to an array of items, and @code{len}
is the count of bytes reserved in the array. The items have the structure:

@example
struct mountinfo @{
    uint32_t fs_type;
    uint32_t flags;
    char source[20];
    uint32_t source_len;
    char location[20];
    uint32_t location_len;
@};
@end example

The total number of mounts is returned, even if it doesnt fit in the passed
array.
@end itemize

The syscall return the requested information on success and @code{-1} on
failure. If the requested value can also be @code{-1}, errno must be checked.

The errno codes set on failure are:

@itemize @bullet
@item
@code{EINVAL}: Invalid request.
@end itemize

@node spawn
@section spawn

@example
pid_t spawn(const char *path, int path_len, char *const argv[], int argv_len, char *const envp[], envp_len);
@end example

This syscalls does exactly the same as a @code{fork}+@code{exec}, but faster
and more efficiently. It has the same returns as @code{fork} and @code{spawn}
together.

@node thread_sched
@section thread_sched

@example
int get_thread_sched(void);
int set_thread_sched(int flags);
@end example

This syscalls manage scheduling properties of the callee thread. Both functions
operate on a bitmap with the following bits

@itemize @bullet
@item
@code{THREAD_MONO (0b1)}: Marks whether the thread is a monothread, see
@xref{Scheduling and predictability} for details.
@end itemize

@code{get_thread_sched} returns the flags and does not fail, while
@code{set_thread_sched} returns @code{0} on success and @code{-1} on failure,
with the following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow the operation.
@end itemize

@node fcntl
@section fcntl

@example
#define FD_CLOEXEC      1
#define F_DUPFD         1
#define F_DUPFD_CLOEXEC 2
#define F_GETFD         3
#define F_SETFD         4
#define F_GETFL         5
#define F_SETFL         6
#define F_GETPIPE_SZ    7
#define F_SETPIPE_SZ    8

int fcntl(int fd, int cmd, int arg);
@end example

This syscall is a multiplexed syscall that performs the operations described
below on the open file descriptor @code{fd}. The operation is determined by
@code{cmd} and may take an optional argument @code{arg}.

The syscall's return value will depend on the requested @code{cmd}, and is
detailed along the operations below.

The valid operations are:

@itemize @bullet
@item
@code{F_DUPFD}: Clones @code{fd} into a the first available file descriptor
starting by @code{arg}. Returns the resulting FD.

@item
@code{F_DUPFD_CLOEXEC}: The same as @code{F_DUPFD} but sets the close on exec
flag for the cloned FD if succesful, in order to save a subsequent call.

@item
@code{F_GETFD}: The flags used for @code{fd} will be returned, right now
only @code{FD_CLOEXEC} is supported. The syscall will return the flags on
success.

@item
@code{F_SETFD}: The flags for @code{fd} will be set with @code{arg}. The
syscall will return @code{0} on sucess.

@item
@code{F_GETFL}: Returns as the function result the file access mode
and status flags.

@item
@code{F_SETFL}: What @code{F_SETFD} is to @code{F_GETFD} for
@code{F_GETFL}.

@item
@code{F_GETPIPE_SZ}: If @code{fd} points to a FIFO or pipe, return
its size.

@item
@code{F_SETPIPE_SZ}: If @code{fd} points to a FIFO or pipe, the size will
be set to the value of @code{arg}. If the operation would cause data loss, it
will fail.
@end itemize

On failure, the syscall returns @code{-1}. The returned @code{errno} are:

@itemize @bullet
@item
@code{EINVAL}: The passed @code{cmd} is not implemented by the kernel.

@item
@code{EBADF}: The passed @code{fd} is not open.
@end itemize

@node exit_thread
@section exit_thread

@example
void exit_thread(void);
@end example

This syscall terminates the calling thread "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getrandom
@section getrandom

@example
ssize_t getrandom(void *buffer, size_t length);
@end example

This syscall fills the buffer pointed to @code{buffer} with up to @code{length}
random bytes. These bytes can be used for cryptographic purposes.

The operation is the same as reading from @code{/dev/random}. It is provided
instead of just reading from the device as to avoid denial of service attacks
based on exhausting the file descriptor limit of the system, along with other
vulnerabilities and inconveniences related to the classic file interface.

The syscall returns the count of read random data or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{buffer} points to invalid memory.
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node mprotect
@section mprotect

@example
int mprotect(void *addr, size_t len, int prot);
@end example

This syscall allows to change the permission of a range of memory of the passed
length pointed by @code{addr}, previously mapped by the caller. The format of
@code{prot} is the same as @code{mmap}.

@code{addr} and @code{len} must be aligned to an architecture-valid alignment.

The syscall returns the @code{0} on success or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{addr} points to invalid memory.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node mac_capabilities
@section mac_capabilities

@example
#define MAC_CAP_SCHED   0b00000000001
#define MAC_CAP_SPAWN   0b00000000010
#define MAC_CAP_ENTROPY 0b00000000100
#define MAC_CAP_SYS_MEM 0b00000001000
#define MAC_CAP_USE_NET 0b00000010000
#define MAC_CAP_SYS_NET 0b00000100000
#define MAC_CAP_SYS_MNT 0b00001000000
#define MAC_CAP_SYS_PWR 0b00010000000
#define MAC_CAP_PTRACE  0b00100000000
#define MAC_CAP_SETUID  0b01000000000
#define MAC_CAP_SYS_MAC 0b10000000000

unsigned long get_mac_capabilities(void);
int set_mac_capabilities(unsigned long request);
@end example

These syscalls allow to fetch and set MAC capabilities on the way described in
@ref{Mandatory access control (MAC)}.

Both syscalls cannot fail, @code{get_mac_capabilities} always returns the
capabilities of the callee process and @code{set_mac_capabilities} always
returns @code{0}, settings will just be ignored if permission to change them
is not granted.

@node add_mac_permissions
@section add_mac_permissions

@example
#define MAC_PERM_CONTENTS 0b0000001
#define MAC_PERM_READ     0b0000010
#define MAC_PERM_WRITE    0b0000100
#define MAC_PERM_EXEC     0b0001000
#define MAC_PERM_APPEND   0b0010000
#define MAC_PERM_FLOCK    0b0100000
#define MAC_PERM_DEV      0b1000000

int add_mac_permissions(const char *path, int flags);
@end example

This syscall adds permissions to access an inode or device as described in
@ref{Mandatory access control (MAC)}.

If @code{MAC_PERM_DEV} is used in @code{flags}, @code{path} must be the name
of a device, without @code{/dev/}, else, it will be taken as a VFS inode. The
other flags reflect permissions given to the added device or inode. All of them
do not conflict.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EPERM}: MAC did not allow this.
@item
@code{EFAULT}: The passed pointer does not point to valid memory.
@item
@code{EAGAIN}: The system has reached a limit on registered rules.
@item
@code{EINVAL}: The passed rule is already covered or conflicts with an existent
one.
@end itemize

@node set_mac_enforcement
@section set_mac_enforcement

@example
#define MAC_DENY            0b001
#define MAC_DENY_AND_SCREAM 0b010
#define MAC_KILL            0b100

int set_mac_enforcement(unsigned long request);
@end example

This syscall sets the action to take for enforcement on MAC issues as explained
in @ref{Mandatory access control (MAC)}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC was locked.
@end itemize

@node mount
@section mount

@example
#define MNT_FAT   1
#define MNT_EXT   2
#define MS_RDONLY 1

int mount(const char *source, int source_len, const char *target,
          int target_len, int fs_type, unsigned long flags);
@end example

This syscall mounts filesystems. @code{source} is the source device while
@code{target} is where to mount in the global virtual filesystem.

@code{fs_type} can be one of the following values to choose the filesystem type
to mount, it must be specified, detection is not done.

@itemize @bullet
@item
@code{MNT_FAT}: FAT family filesystem.
@item
@code{MNT_EXT}: EXT family filesystem.
@end itemize

@code{flags} may contain @code{MS_RDONLY} to force mounting read-only mounting.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: Wrong arguments.
@end itemize

@node umount
@section umount

@example
#define MNT_FORCE 1

int umount(const char *target, int target_len, int flags);
@end example

This syscalls unmount FSs. @code{target} is the path to unmount, while
@code{flags} allows the following options:

@itemize @bullet
@item
@code{MNT_FORCE}: Unmount the filesystem even if busy, can cause data loss.
@end itemize

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EBUSY}: The mount is busy, and @code{MNT_FORCE} was not passed.
@end itemize

@node readlink
@section readlink

@example
ssize_t readlink(char *path, int path_len, char *buffer, size_t buffer_len);
@end example

The syscall reads the redirected path of a symlink.

The syscalls return the read length on success or @code{-1} on failure, with
the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: The passed file is not a symbolic link.
@end itemize

@node getdents
@section getdents

@example
#define DT_UNKNOWN 0
#define DT_FIFO    1
#define DT_CHR     2
#define DT_DIR     4
#define DT_BLK     6
#define DT_REG     8
#define DT_LNK    10
#define DT_SOCK   12
#define DT_WHT    14

struct dirent @{
   uint64_t d_ino;
   uint64_t d_off;
   uint16_t d_reclen;
   uint8_t  d_type;     // One of the DT_ values.
   char     d_name[61]; // Null-terminated.
@};

ssize_t getdents(int fd, struct dirent *buffer, size_t size);
@end example

The syscall reads the contents of a directory all in one go, partial reads
are not supported.

The syscalls return the read length in bytes on success, or @code{0} if no
contents or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the arguments.
@item
@code{EBADFD}: @code{fd} does not contain a valid file.
@item
@code{ENOENT}: @code{fd} is not a directory.
@item
@code{EINVAL}: @code{size} is not big enough to fit all the directory entries.
@end itemize

@node sync
@section sync

@example
int sync(void);
@end example

The syscall flushes the associated caches of all FSes and the devices that
contain said FSs, ensuring that all operations are finished, this can be used
in order to ensure data coherency on power loss or program failure.

The syscall returns @code{0} or @code{-1} on failure, with a corresponding
errno:

@itemize @bullet
@item
@code{EIO}: Device error while flushing.
@end itemize

@node mknod
@section mknod

@example
int mknod(int dir_fd, const char *path, int path_len, int mode, int dev);
@end example

This syscall creates files in the passed path and dir. The type is chosen by
@code{code}, which uses the same format as @code{stat}'s mode field.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path length is way too big, or the mode is invalid.
@item
@code{EIO}: Internal error.
@end itemize

@node truncate
@section truncate

@example
int truncate(int fd, uint64_t new_size);
@end example

The syscall truncates the size of @code{fd} on disk to exactly @code{new_size}
bytes.

If the file was larger, the cropped contents are lost, if it was smaller, the
new data is zero'd out. No other file data is changed.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The file pointed by @code{fd} is not valid for truncation.
@item
@code{EINVAL}: @code{new_size} could not be set.
@end itemize

@node mkdir
@section mkdir

@example
int mkdir(int dir_fd, const char *path, int path_len, int mode);
@end example

This syscall creates directories in the passed path.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path length is way too big.
@item
@code{EIO}: Internal error.
@end itemize

@node symlink
@section symlink

@example
int symlink(int dir_fd, const char *path, int path_len,
            const char *target, int target_len, int mode);
@end example

This syscall creates symlinks for the passed path and mode.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path and target lengths are way too big, or the
passed mode is invalid.
@item
@code{EIO}: Internal error.
@end itemize

@node integrity_setup
@section integrity_setup

@example
#define INTEGRITY_SET_POLICY    1
#define INTEGRITY_RUN_YOURSELF  2
#define INTEGRITY_STOP_YOURSELF 3
#define INTEGRITY_ONESHOT       4
#define INTEGRITY_FREE_MEMORY   5
#define INTEGRITY_MAX_PROC      6

#define INTEGRITY_POLICY_WARN  1
#define INTEGRITY_POLICY_PANIC 2

int integrity_setup(int request, uint64_t argument);
@end example

The syscall configures the integrity check facilities.

@code{request} can be one of the following:

@itemize @bullet
@item
@code{INTEGRITY_SET_POLICY (1)}: Set the failure policy to the value passed in
@code{argument}, which has to be one of the @code{INTEGRITY_POLICY_} family.

@item
@code{INTEGRITY_RUN_YOURSELF (2)}: Tell the kernel to launch the kernel-side
periodic integrity checks, @code{argument} is the ms deadline for each test.

@item
@code{INTEGRITY_STOP_YOURSELF (3)}: Tell the kernel to stop the kernel-side
checks.

@item
@code{INTEGRITY_ONESHOT (4)}: Run the checks.

@item
@code{INTEGRITY_FREE_MEMORY (5)}: Check for at least @code{argument} free
bytes of memory next check.

@item
@code{INTEGRITY_MAX_PROC (6)}: Check that the total number of processes in
the system does not equal or exceed @code{argument}.
@end itemize

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid configuration value combination.
@end itemize

@node openpty
@section openpty

@example
int openty(int ptys[2], struct termios *t, struct win_size *w);
@end example

This syscalls creates a pair of pseudoterminals and returns the registered
file descriptors in @code{ptys}. Index @code{0} is the primary end
(also known as master), @code{1} is the secondary end (also known as slave).

@code{t} and @code{w} are the termios and window information the created
pseudoterminals will contain.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{ptys}, @code{t}, or @code{w}, point to bogus memory.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node fsync
@section fsync

@example
int fsync(int fd, int flags);
@end example

The syscall does the same as @code{sync}, just only applied to @code{fd}. If
the passed file is a device, the device will flush its internal caches.

If the file was just created, one might considering synchronizing the parent
directory as well, as, depending on the FS and FS driver, parent directory
entries are stored separately to the file, EXT-series filesystems come to mind.

If @code{flags} is not zero, only the data of the passed descriptor will be
guaranteed to be flushed, and not modified metadata, this can be used in
order to minimize disk activity even further.

The syscall returns @code{0} or @code{-1} on failure, with the errno:

@itemize @bullet
@item
@code{EINVAL}: The passed file does not exist or points to a non-flushable
entity, like a pipe or pseudoterminal.
@item
@code{EIO}: FS or device error while flushing.
@end itemize

@node link
@section link

@example
int link(int dir_fd, const char *path, int path_len,
         const char *target, int target_len);
@end example

This syscall creates hard links, the paths are not dereferenced in the case
of being symlinks.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path and target lengths are way too big.
@item
@code{EIO}: Internal error.
@end itemize

@node ptrace
@section ptrace

@example
#define PTRACE_SYSCALL_PIPE 1

long ptrace(long request, pid_t pid, void *addr, void *data);
@end example

This syscall can be used for tracing, debugging, execution control, and info
reporting of data owned by a child process. The operations is indicated by
@code{request}, while the PID to act upon is @code{pid}, @code{addr} the
address in the child process to modify, and @code{data} what to modify with.

@code{request} can be one of:

@itemize @bullet
@item
@code{PTRACE_SYSCALL_PIPE (1)}: @code{data} will be taken as an FD in the
child process, which the kernel will use to report the state on every syscall
the child process does. The descriptor must be a pipe, no other files are
supported. Errors writing are silently ignored.
@end itemize

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow this.
@item
@code{EPERM}: @code{pid} is not a child or does not exist.
@item
@code{EINVAL}: @code{request} is not valid.
@end itemize

@node poll
@section poll

@example
#define POLLIN   0b00000001
#define POLLOUT  0b00000010
#define POLLERR  0b00001000
#define POLLHUP  0b00010000
#define POLLNVAL 0b01000000

struct pollfd @{
   uint32_t fd;
   uint16_t events;
   uint16_t revents;
@};

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
@end example

This syscall allows to wait for a series of events to happen to the passed
FDs, in a manner similar to POSIX's @code{select}.

@code{fds} is an array of @code{nfds} length of @code{pollfd} structures. Each
structure represents one FD, for which @code{events} is a bitmap of events
to wait for and @code{revents} is a bitmap written by the kernel to indicate
which events of the waited ones did happen. If the FD of an structure is
negative, that is, it has the first bit set, it is ignored, and @code{revents}
is set to @code{0}.

Both @code{events} and @code{revents} are bitmaps of the values:

@table @code
@item POLLIN
The passed FD has data pending for reading.

@item POLLOUT
The passed FD will not block when written to (a sensible amount).

@item POLLERR
Only for @code{revents}, it is set in the case of error waiting, or if the FD
is a pipe and the connection is broken with no data pending.

@item POLLHUP
Only for @code{revents}, it is set in the case of the passed FD having lost
connection, or the FD being a broken pipe, but still having data pending.

@item POLLNVAL
Only for @code{revents}, equivalent of @code{EBADFD}, that is, the passed FD
is not valid.
@end table

@code{timeout} argument specifies the number of milliseconds that the syscall
should block waiting for a file descriptor to become ready. The call will block
until either a file descriptor gets an event, the call is interrupted by a
signal handler, or the timeout expires.

The syscall returns the number of FDs to have an event happen on success or
@code{-1} on failure, with the following errno:

@table @code
@item EFAULT
The passed pointers are not in addressable memory.

@item EINVAL
The passed values are not valid.
@end table

@node getuid/geteuid
@section getuid/geteuid

@example
uid_t getuid(void);
uid_t geteuid(void);
@end example

These syscalls fetch the UID and the effective UID of the calling process. They
never fail.

@node setuids
@section setuids

@example
int setuids(uid_t uid, uid_t euid);
@end example

This syscall sets the UID and effective UID of the calling process, if any
of them is @code{-1}, it will not be set. @code{MAC_CAP_SETUID} is required
for this operation.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed values are not valid, or out of range.

@item EACCES
MAC did not allow this.
@end table

@node fchmod
@section fchmod

@example
int fchmod(int fd, mode_t mode);
@end example

This syscall sets the mode for the passed FD taking umask into account.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD or mode is not valid.

@item EACCES
MAC did not allow this.
@end table

@node umask
@section umask

@example
mode_t umask(mode_t mask);
@end example

This syscall sets the umask of the calling process to the passed mask AND'd
with @code{777} in octal.

The umask is used by the kernel when creating files in the name of the calling
process. It marks permissions to be turned off from @code{mode} arguments
passed by the user. The default value is @code{22} in octal, and is inherited
from parent processes to children.

This syscall never fails, it always returns the old mask before modification.

@node reboot
@section reboot

@example
#define RB_HALT     1
#define RB_POWEROFF 2
#define RB_RESTART  3
#define RB_ERROR_RET 0b1

int reboot(int cmd, int flags);
@end example

This syscall does the passed action to the system's power management, the
action is specified with @code{cmd}, it can be one of:

@table @code
@item RB_HALT
System activity is terminated and the system will make all needed preparations,
but power will not be cut off, instead, the user will have to do so, say, with
the power button. Data syncing is up to the user.

@item RB_POWEROFF
The same as @code{RB_HALT} but actually cuts power.

@item RB_RESTART
The same as @code{RB_HALT} but at the end, the system will reboot.
@end table

If the operation fails internally, for any reason, the kernel will panic, for
returning an error instead, one can use @code{RB_ERROR_RET} in @code{flags}.

This syscall does not return on success, it will only return in the case of
invalid value for @code{cmd}, before comitting to an operation, or by using
@code{RB_ERROR_RET} as previously said. In error, @code{-1} will be returned,
and errno will be set to:

@table @code
@item EINVAL
The passed @code{cmd} is not valid.

@item EACCES
MAC did not allow this.

@item EIO
The operation failed internally.
@end table

@node fchown
@section fchown

@example
int fchown(int fd, uint32_t user, uint32_t group);
@end example

This syscall sets the owner's UID and GID for the passed FD.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD or the user and group were not valid.

@item EACCES
MAC did not allow this.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node pread/pwrite
@section pread/pwrite

@example
ssize_t pread(int fd, void *buffer, size_t count, off_t offset);
ssize_t pwrite(int fd, void *buffer, size_t count, off_t offset);
@end example

These syscalls do the same as @code{read} and @code{write} respectively, but
instead of using the description's saved location for data access, they use the
passed @code{offset}, and do not update it at the end of the operation.
@code{fd} must point to a seekable file.

These syscalls are made for use in multithreaded applications, as having more
than one thread updating file locations for a shared file description can lead
to sudden catharsis.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed fd is not suitable for the operation.

@item
@code{EIO}: The requested operation failed at the device level.
@end itemize

@node Filesystems support and interfaces
@chapter Filesystems support and interfaces

Ironclad supports a series of filesystems, with filesystem-specific quirks at
times, and exposes interfaces with @code{ioctl} calls.

@node Extended FileSystem
@section Extended FileSystem

Ironclad supports EXT-series filesystems read-only and read-write.

While a user may be used to the ext2/3/4 distinction, EXT internally works as
an independent set of features, with the version numbers specifying a
widely understood, assumed, and inconsistent set of features.

Ironclad supports the feature list: @code{sparse_super}, @code{large_file},
@code{filetype}, @code{resize_inode}, @code{dir_index}, @code{ext_attr}.

Those features should translate to ext2 read-write support, and ext3 read-only
support.

Some @code{ioctl} calls exist for files inside EXT-series FSs, which can help
manage specialized FS-specific inode flags and permissions, they are:

@example
EXT_GETFLAGS = 0x5600
EXT_SETFLAGS = 0x5601

ioctl(fd, EXT_GETFLAGS, pointer_to_u32); // Get EXT's flags inode field.
ioctl(fd, EXT_SETFLAGS, pointer_to_u32); // Set EXT's flags inode field.
@end example

@node File Allocation Table
@section File Allocation Table

Ironclad's FAT support is really rough. Only read-only FAT32 is supported.
No special @code{ioctl} calls are provided. Long filenames are not supported.

@node Devices and their properties
@chapter Devices and their properties

Ironclad exposes a number of physical and virtual devices to userland. All
of them are exposed under the @code{/dev} location, and support a series of
standard operations, like being manipulated by the usual file-related
syscalls like @code{read} or @code{write}, while sporting device-specific
interfaces in the form of device-specific @code{ioctl} requests.

When quering device-specific information, Ironclad exposes information a bit
different than other kernels like Linux. Here is a quick list of the most
notable differences:

@itemize @bullet
@item
The @code{BLKGETSIZE}/@code{BLKGETSIZE64} @code{ioctl} calls are not available,
instead, the block count and block size values of @code{stat} are used.
@end itemize

@node Common devices
@section Common devices

These are devices exposed in Ironclad regardless of target system when
present, with standardized interfaces.

@subsection debug

@code{/dev/debug} wraps architecture-specific debug output channels for use
with file operations. For x86-based targets, this is COM0, for ARM-based
and SPARC-based targets, this is UART.

@subsection ramdev

The devices starting by @code{ramdev} are virtual devices representing the
RAM driver passed by some boot protocols, an FS can be mounted to them, or be
otherwise used like any other block device. These RAM devices are read-only.

@subsection random

The device @code{random} is equivalent to the one featured in other unix-like
kernels. Keep in mind that Ironclad has limited sources of entropy, so the
quality of this random numbers is a bit limited. Writing to the source is not
allowed, unlike other systems.

@code{/dev/urandom} does the same as @code{/dev/random}, and is only provided
for compatibility.

@code{getrandom} is provided as well for avoiding the file interface, and that
way avoid certain kinds of DoS attacks.

@subsection null/zero

@code{null} returns @code{EOF} whenever read, and all the write operations are
discarded.

@code{zero} returns exclusively a stream of zeros when read, and all write
operations are discarded.

@subsection rtc

@code{/dev/rtc} exposes the hardware RTC in an architecture independent manner.

The device does not allow any file operations but the following @code{ioctl}:

The time structures handled represent ready-to-use, calendar timestamps.

@example
RTC_RD_TIME  = 1 // Reads time to the passed structure.
RTC_SET_TIME = 2 // Sets the RTC to the passed time.
struct rtc_time @{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;     /* unused */
    int tm_yday;     /* unused */
    int tm_isdst;    /* unused */
@};

ioctl(rtc, ..., pointer_to_rtc_time)
@end example

@node aarch64-stivale2 devices
@section aarch64-stivale2 devices

@subsection pl011

The device @code{pl011} supports read operations for PL011 UART compatible
devices.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented, only the ones related to input stream
settings.

The default baud for the device is set to be @code{115200}.

@node arm-raspi2b devices
@section arm-raspi2b devices

@subsection uart

@code{uart} supports read and write operations for the PL011 UART device
featured on the board on GPIOs 14 and 15 (pins 8 and 10).

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented, only the ones related to input stream
settings.

The default baud for the device is set to be @code{115200}.

@subsection watchdog

@code{watchdog} represents the hardware watchdog included with the board.
Writing to it will reset it, @code{ioctl} operations may be used for
timeout configuration and starting/stopping it.

@node sparc-leon3 devices
@section sparc-leon3 devices

This target has no special devices.

@node x86_64-multiboot2 devices
@section x86_64-multiboot2 devices

@subsection ata

The devices starting by @code{sata} represent several ATA IDE block devices.
These ATA drives have internal caching at the driver level, so they must be
@code{sync}'d for data integrity when wanting to ensure data coherency.

No special @code{ioctl} calls are supported.

@subsection fb0

The @code{fb0} device exposes the framebuffer passed as part of the boot
protocol, when present. The device uses Linux's @url{https://docs.kernel.org/fb/api.html, fbdev} interface.

@subsection ps2keyboard/ps2mouse

The devices @code{ps2keyboard} and @code{ps2mouse} exposes x86's native PS2
interfaces, @code{ps2keyboard} is a normal character device that returns
scancodes as they are received. @code{ps2mouse} is a character device that
returns mouse packets following the structure:

@example
struct mouse_data @{
   uint32_t x_variation;
   uint32_t y_variation;
   uint8_t  is_left_click;
   uint8_t  is_right_click;
@};
@end example

@code{ps2mouse} supports a series of @code{ioctl} calls for setting different
modes and talking directly with the PS2 controller:

@example
PS2MOUSE_2_1_SCALING     = 1
PS2MOUSE_1_1_SCALING     = 2
PS2MOUSE_SET_RES         = 3
PS2MOUSE_SET_SAMPLE_RATE = 4

ioctl(mouse, PS2MOUSE_2_1_SCALING, ignored);  // Enable 2:1 scaling.
ioctl(mouse, PS2MOUSE_1_1_SCALING, ignored);  // Enable 1:1 scaling.
ioctl(mouse, PS2MOUSE_SET_RES, resolution);   // (0 - 3).
ioctl(mouse, PS2MOUSE_SET_SAMPLE_RATE, rate); // (0 - 200).
@end example

Valid resolutions and sample rates are values for the PS2 controller, else
the call is ignored. For valid values and their meaning refer to
@uref{https://isdaman.com/alsos/hardware/mouse/ps2interface.htm, this website}.

@subsection sata

The devices starting by @code{sata} represent several SATA AHCI block devices.
For now only SATA drives are supported, support for ATAPI is not present.

These SATA drives have internal caching at the driver level, so they must be
@code{sync}'d for data integrity when wanting to ensure data coherency.

@subsection serial

The devices starting by @code{serial} represent the several character devices
used for each present serial port, they support read/write operations, but no
TTY interface is exposed, they are raw byte streams.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented as the serial devices are not ttys but
just byte streams.

The default baud for all ports is set to be @code{115200}.

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texi

@bye
