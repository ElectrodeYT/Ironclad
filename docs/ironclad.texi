\input texinfo
@setfilename ironclad.info
@documentencoding UTF-8
@settitle Ironclad User's Guide

@copying
Copyright @copyright{} 2023 streaksu

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@title Ironclad User's Guide
@subtitle Userland interfaces and devices, features, and kernel internals.
@author streaksu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents

@ifnottex
@node Top
@top Ironclad User's Guide

This manual documents usage of Ironclad, interfaces and devices it exposes to
userland, and discusses kernel internals, without having to navigate the often
cryptic and scary Ada code.

@insertcopying
@end ifnottex

@menu
* Installation and target support::    Installation and hardware support.
* Boot-time command-line options::     Command-line options.
* Scheduling and RTC::                 Scheduling methodology and features.
* Memory architecture::                Memory architecture of the kernel.
* Userland state and conditions::      Userland state and conditions.
* Security and integrity facilities::  Ironclad-specific security facilities.
* Debugging facilities::               Ironclad-specific debugging facilities.
* Syscalls::                           Listings and explanation of syscalls.
* Filesystem support and interfaces::  VFS details and supported filesystems.
* Devices and their properties::       Devices exposed by the kernel.
* GNU Free Documentation License::     Copying and sharing this manual.

@detailmenu
--- The Detailed Node Listing ---

Installation and target support

* aarch64-stivale2 support::   aarch64-stivale2 installation and support.
* arm-raspi2b support::        arm-raspi2b installation and support.
* sparc-leon3 support::        sparc-leon3 installation and support.
* x86_64-multiboot2 devices::  x86_64-multiboot2 installation and support.

Boot-time command-line options

* Format::                 Description of the format.
* List::                   List of all the available cmdline arguments.

Scheduling and RTC

* Ticks and other interruptions::    Thread interruptions to expect.
* Scheduling basics::                 Algorithms used in Ironclad.
* Thread clustering and management::  Thread clusters in Ironclad.

Memory architecture

* Physical memory allocation::  How the kernel goes about allocating memory.
* Virtual memory::              Virtual memory architecture.

Userland state and conditions

* Program loading::  Format of the loaded programs.
* Memory layout::    Layout of memory in userland.

Security and integrity facilities

* Users and groups::                UIDs, EUIDs, GIDs, and all the fuzz.
* Mandatory access control (MAC)::  MAC quickguide and configuration.
* Resource limits::                 Limits on resources built into MAC.
* Miscellaneous measures::          Miscelaneous security measures.

Debugging facilities

* Corefile and process dumping::    Format of dumped files, and settings.
* Program tracing::                 Details on program tracing.

Syscalls

* Table and target quirks:: Syscall table and architectural ABI.
* Errno::                   Error conditions and their values.
* exit::                    Exit the callee process.
* arch_prctl::              Interacting with architectural thread-local data.
* open::                    Opening file-system entities.
* close::                   Closing file descriptors.
* read/write::              Read and write from file descriptors.
* seek::                    Modify and fetch file offsets.
* mmap/mprotect/munmap::    Manage memory regions.
* getpid/getppid::          Get the PIDs of the caller.
* exec::                    Launching new programs.
* clone::                   Create new processes and threads.
* wait::                    Waiting for execution of a child to finish.
* socket::                  Create sockets.
* sethostname::             Hostname setting.
* unlink::                  Queue files for deletion.
* fstat::                   Fetch file information.
* chdir::                   Current working directory manipulation.
* ioctl::                   IO multiplexer.
* sched_yield::             Relinquish CPU time.
* delete_tcluster::         Delete thread clusters.
* pipe::                    Create pipes.
* rename::                  Rename a file.
* sysconf::                 Fetch general system parameters and information.
* spawn::                   clone+exec power incarnate.
* gettid::                  Get the current thread id.
* manage_tcluster::         Manage and create thread clusters.
* fcntl::                   Multiplexed operations for files.
* exit_thread::             Exit the calling thread.
* getrandom::               Bypass /dev/random for avoiding DoS attacks.
* mac_capabilities::        Get and set MAC capabilities.
* add_mac_permissions::     Configure MAC using filesystem-based filters.
* set_mac_enforcement::     Set enforcement to follow on MAC violations.
* mount/umount::            Mount and unmount partitions.
* readlink::                Read the contents of a symlink.
* getdents::                Get directory entries.
* sync::                    Synchronize device caches.
* mknod::                   Create several kinds of files.
* truncate::                Truncate the contents of a file to an offset.
* bind::                    Bind sockets to locations.
* mkdir::                   Create directories.
* symlink::                 Create symbolic links.
* connect::                 Connect a socket.
* openpty::                 Create pseudoterminals.
* fsync::                   Synchronize file-specific caches.
* link::                    Create hard links.
* ptrace::                  Trace and debug children processes.
* listen::                  Listen for connections to a socket.
* accept::                  Accept socket connections.
* getrlimit/setrlimit::     Get and set resource limits.
* access::                  Check file access permissions and existance.
* poll::                    I/O event multiplexer.
* getuid/geteuid::          Get the UID and the effective UID.
* setuids::                 Set the UID and the effective UID.
* fchmod::                  Change the mode of a file descriptor.
* umask::                   Get and set the calling process umask.
* reboot::                  Machine power management.
* fchown::                  Change ownership of a file descriptor.
* pread/pwrite::            Atomic read and write from file descriptors.
* getsockname::             Get address of a bound socket.
* getpeername::             Get address of a socket's peer.
* shutdown::                Disconnect socket from its peer.

Filesystem support and interfaces

* Extended FileSystem::    EXT-series filesystems (ext2, ext3, ext4).
* File Allocation Table::  FAT-series filesystems.
* QNX4 FileSystem::        The default filesystem of QNX4 Neutrino.

Devices and their properties

* Common devices::             Devices common to all architectures and targets.
* aarch64-stivale2 devices::   Devices specific to aarch64-stivale2.
* arm-raspi2b devices::        Devices specific to arm-raspi2b.
* sparc-leon3 devices::        Devices specific to sparc-leon3.
* x86_64-multiboot2 devices::  Devices specific to x86_64-multiboot2.

@end detailmenu
@end menu

@node Installation and target support
@chapter Installation and target support

This chapter delves on what hardware configurations Ironclad supports and how
to get Ironclad running on those platforms.

Ironclad hardware support is divided in targets, which are combos of
an architecture and board that are supported in tandem, along with any
accompaning hardware, some hardware is supported regardless of the underlying
target, @ref{Common devices}.

@node aarch64-stivale2 support
@section aarch64-stivale2 support

aarch64 systems are supported using the stivale2 boot protocol, any
stivale2 compliant aarch64 bootloader like sabaton will boot it just fine.

For supported devices and how they are abstracted,
@ref{aarch64-stivale2 devices}.

@node arm-raspi2b support
@section arm-raspi2b support

Raspberry Pi 2b boards are supported, the image can be loaded straight from
the firmware by putting it in the boot partition with the same names and
configuration that a Linux image would use.

For supported devices and how they are abstracted, @ref{arm-raspi2b devices}.

@node sparc-leon3 support
@section sparc-leon3 support

LEON3 boards, based on SPARCv8 processors, are supported, in this case, the
kernel must be loaded straight from the board's firmware, no bootloaders are
needed.

For supported devices and how they are abstracted, @ref{sparc-leon3 devices}.

@node x86_64-multiboot2 support
@section x86_64-multiboot2 support

x86_64 systems are supported using the multiboot2 boot protocol, any
multiboot2 compliant bootloader like GNU GRUB or Limine will be able to boot
it just fine.

For supported devices and how they are abstracted,
@ref{x86_64-multiboot2 devices}.

@node Boot-time command-line options
@chapter Boot-time command-line options

Ironclad takes, as part of its boot protocol, a series of options and values.
The parsing of this options is architecture and platform independent, while the
ability to modify said options and values is entirely up to the platform and
bootloader.

@node Format
@section Format

The format is a list of keys that can have arguments or not in a C-style
NUL-terminted string, as such:

@example
key1=value1 key2 key3=value3 ... keyN
@end example

@node List
@section List

This are the keys and values the kernel takes, and under which circumstances:

@table @code
@item root=<device>
Device to mount as root, if any.

@item init=<path>
Path to a program that will be booted by the kernel when finished loading.
The program will be started with @code{stdin} set to @code{/dev/null}, and
@code{stdout} and @code{stderr} set to @code{/dev/debug}.

@item noprogaslr
The offset of loaded programs in virtual memory is randomized when loading if
possible, this option disables it system-wide at boot time and hardcodes it to
the lowest available value.

@item nolocaslr
The same as @code{noprogaslr} but applied to memory locations like stacks
and memory allocation.
@end table

@node Scheduling and RTC
@chapter Scheduling and RTC

Ironclad is built around hard real-time work, this chapter explains how that
is accomplished along with how scheduling works, predictability of it, and
other useful related features.

@node Ticks and other interruptions
@section Ticks and other interruptions

Ironclad will not interrupt a running thread for timers or heartbeats, if
necessary, at the expense of performance by, for example, using polling instead
of interrupt-based operation for device drivers.

A thread, however, may be interrupted for task-switching, which is needed for
scheduling to work. This will not be an issue for most operations, but if the
user desires absolutely 0 interruptions and/or jitter, one can use

@node Scheduling basics
@section Scheduling basics

Scheduling in Ironclad is based on time sharing, under this idea, threads in
Ironclad are divided on groups that are a percentage of the overall CPU time.

@node Thread clustering and management
@section Thread clustering and management

The divisions explain at @ref{Scheduling basics} are called thread clusters in
Ironclad. Thread clusters rule over a group of threads, regardless of their
process of origin, and allow specifiying an algorithm and a percentage over
all the CPU time.

The algorithm of a cluster only affects how threads inside the cluster are
scheduled. The available algorithms are:

@table @code
@item SCHED_RR
A flat round robin with no priorities, one can specify a quantum for tasks
to use while rotating.

@item SCHED_COOP
Cooperative scheduling, the scheduler will not attempt to preempt unless
explicitly requested by exiting or yielding.
@end table

Additionally, by using the @code{SCHED_INTR} flag, a cluster can be configured
to be interruptible, which makes the kernel able to interrupt and break the
specified quantum in order to increase performance and responsiveness during
waits. The same rules as normal scheduling apply for these interruptions.

At startup, Ironclad will have a single interruptible cluster assigned to 100%
of execution time, configured to use a flat RR with a reasonable quantum with
cluster number @code{1}. Software is free to modify it however it sees fit, it
is just provided in order to have some natural-ish behaviour for running
software.

@node Memory architecture
@chapter Memory architecture

Ironclad features several memory allocator choices for use, the chosen
allocator will be used both for kernel and userland allocations.

@node Physical memory allocation
@section Physical memory allocation

The standard allocator is a general purpose allocator for your average
everyday allocator needs. Its internally implemented as a bitmap allocator with
page-sized blocks and a quick cache for small objects, along with some quick
hardening features, like checksums.

An alloconly option is provided, which features several optimizations on top
of the usual allocator in order to save memory and tune operation, for usecases
where nor userland nor the kernel are wanted to dealocate memory at all.

@node Virtual memory
@section Virtual memory

The virtual memory architecture of Ironclad is quite simple, given the need
to avoid things like complex virtual memory management which could influence
predictability with page-related interrupts, and similar features. For the same
reason, memory overcommiting is not allowed.

@node Userland state and conditions
@chapter Userland state and conditions

Ironclad places several requirements on loaded userland programs, from the
format of which, to memory layout.

@node Program loading
@section Program loading

Loaded programs must be under the ELF64 format, other formats may be supported
in the future. Loaded programs can be static or relocatable.

@code{ld.so}, or any other linker program detailed on the interpreter segment
of the ELF executable will be a special case, it is assumed to be relocatable.

@node Memory layout
@section Memory layout

Loaded programs are loaded at address 0, and they are free to allocate
themselves at nearby offsets.

@code{ld.so} and entities like stacks, anonymous memory regions, and others,
will be randomized on load time following
@uref{https://en.wikipedia.org/wiki/Address_space_layout_randomization, ASLR},
and must not be relied upon. It is up to @code{ld.so} to optionally place
additionally loaded libraries at random offsets.

The stack is a fixed @code{128 KiB} in size, and is not executable, by default.

@node Security and integrity facilities
@chapter Security and integrity facilities

This chapter digs into the various Ironclad-specific security and integrity
features available for the user.

@node Users and groups
@section Users and groups

As part of the UNIX-like package, Ironclad supports the traditional UID/EUID
values per-process for basic access protection, both for files and syscalls.

Unlike most UNIX systems, the @code{setuid} bit is fully ignored and not
implemented, instead, as part of the mandatory access control facilities
explained later, @code{MAC_CAP_SETUID} is provided, with similar functionality.

Groups are not supported in any shape or form.

@node Mandatory access control (MAC)
@section Mandatory access control (MAC)

Mandatory access control (MAC) is one of the main components of Ironclad's
security. It does not necesarily help with preventing breaches, but, when
configured correctly, it can help mitigate consequences to a massive degree.

MAC in Ironclad consists on a series of settings inherited from parent process
to children, These settings come in the form of capabilities and file filters.

Capabilities are a set of coarse permissions that restrict a process on what it
can and cannot do, only more restrictive capability escalations are allowed,
they are configured using @ref{mac_capabilities}.

The available capability list is:

@table @code
@item MAC_CAP_SCHED
The process will be allowed to change its own scheduling rules, like modifying
deadlines.

@item MAC_CAP_SPAWN
The process will be allowed to spawn other processes and threads.

@item MAC_CAP_ENTROPY
The process will have unrestricted access to the sources of entropy of the
kernel, this does not cover the UNIX-standard @code{random/urandom}.

@item MAC_CAP_SYS_MEM
The process will be able to allocate and deallocate both private and shared
memory regions.

@item MAC_CAP_USE_NET
The process will be able to use networking.

@item MAC_CAP_SYS_NET
The process will be able to modify networking, for things like hostname
changing.

@item MAC_CAP_SYS_MNT
The process will be able to modify, add, and remove mountpoints.

@item MAC_CAP_SYS_PWR
The process will be able to modify power settings, along doing things like
shutdown and reboot.

@item MAC_CAP_PTRACE
The process will be able to use ptrace on children processes.

@item MAC_CAP_SETUID
The process will be able to change its effective and global UIDs without
checks.

@item MAC_CAP_SYS_MAC
The process will be able to add allowed inodes to the MAC definitions, along
with modifying hard limits for system resources.
@end table

Access to inodes and devices can be granted using @ref{add_mac_permissions}.

The action to take on MAC violations can be set with @ref{set_mac_enforcement}.
Possible values include denying requests, killing the offending part outright,
or denying and additionally logging the event.

Once booted, MAC is enabled and gives full access to all capabilities, and
offers full access to all inodes and devices. It is up to userland to further
restrict access, and for those settings to trickle down to children processes.
File access enforcement will kick in only once the first filter is added with
@ref{add_mac_permissions}.

@node Resource limits
@section Resource limits

As part of the UNIX-like package, Ironclad supports various resource limits
that, in the case of Ironclad, are built inside MAC, and are passed down like
MAC capabilities (@pxref{Mandatory access control (MAC)}).
@xref{getrlimit/setrlimit}

@node Miscellaneous measures
@section Miscellaneous measures

@subsection W^X

Ironclad does not allow mapping memory sections write and execute at the same
time, this helps mitigate several kinds of memory corruption vulnerabilities
by making it much harder to transform them into arbitrary code execution.

@node Debugging facilities
@chapter Debugging facilities

This chapter digs into the various Ironclad-specific debugging features
available for the user.

@node Corefile and process dumping
@section Corefile and process dumping

Ironclad implements corefile dumping when a process irreparably crashes, which
can be controlled and entirely disabled if wanted with the related limits, see
@ref{Resource limits}.

Corefiles are only generated if the file does not exist already, files are
never overwritten, the path is:

@example
/tmp/<faulting PID>.core
@end example

It is not configurable. The format so far is just an architecture-specific
register dump, but in the future a standard ELF format will replace it.

@node Program tracing
@section Program tracing

Ironclad allows tracing children processes for a variety of information, MAC
willing, see @ref{ptrace}.

@node Syscalls
@chapter Syscalls

Syscall are the main method for userland to interface with the kernel's
facilities, this section delves into the mechanism and how it works.

@node Table and target quirks
@section Table and target quirks

Syscalls in Ironclad have an architecture-dependent ABI, but the table and its
indexes are always the same, this is done to simplify development. and here is a list of the
supported architectures and the ABI for each of them. Here is the table:

@enumerate 0
@item
@ref{exit}.
@item
@ref{arch_prctl}.
@item
@ref{open}.
@item
@ref{close}.
@item
@ref{read/write, read}.
@item
@ref{read/write, write}.
@item
@ref{seek}.
@item
@ref{mmap/mprotect/munmap, mmap}.
@item
@ref{mmap/mprotect/munmap, munmap}.
@item
@ref{getpid/getppid, getpid}.
@item
@ref{getpid/getppid, getppid}.
@item
@ref{exec}.
@item
@ref{clone}.
@item
@ref{wait}.
@item
@ref{socket}.
@item
@ref{sethostname}.
@item
@ref{unlink}.
@item
@ref{fstat}.
@item
Empty.
@item
@ref{chdir}.
@item
@ref{ioctl}.
@item
@ref{sched_yield}.
@item
@ref{delete_tcluster}.
@item
@ref{pipe}.
@item
@ref{getuid/geteuid, getuid}.
@item
@ref{rename}.
@item
@ref{sysconf}.
@item
@ref{spawn}.
@item
@ref{gettid}.
@item
@ref{manage_tcluster}.
@item
@ref{fcntl}.
@item
@ref{exit_thread}.
@item
@ref{getrandom}.
@item
@ref{mmap/mprotect/munmap, mprotect}.
@item
@ref{sync}.
@item
@ref{mac_capabilities, set_mac_capabilities}.
@item
@ref{mac_capabilities, get_mac_capabilities}.
@item
@ref{add_mac_permissions}.
@item
@ref{set_mac_enforcement}.
@item
@ref{mount/umount, mount}.
@item
@ref{mount/umount, umount}.
@item
@ref{readlink}.
@item
@ref{getdents}.
@item
@ref{mknod}.
@item
@ref{truncate}.
@item
@ref{bind}.
@item
@ref{symlink}.
@item
@ref{connect}.
@item
@ref{openpty}.
@item
@ref{fsync}.
@item
@ref{link}.
@item
@ref{ptrace}.
@item
@ref{listen}.
@item
@ref{accept}.
@item
@ref{getrlimit/setrlimit, getrlimit}.
@item
@ref{getrlimit/setrlimit, setrlimit}.
@item
@ref{access}.
@item
@ref{poll}.
@item
@ref{getuid/geteuid, geteuid}.
@item
@ref{setuids}.
@item
@ref{fchmod}.
@item
@ref{umask}.
@item
@ref{reboot}.
@item
@ref{fchown}.
@item
@ref{pread/pwrite, pread}.
@item
@ref{pread/pwrite, pwrite}.
@item
@ref{getsockname}.
@item
@ref{getpeername}.
@item
@ref{shutdown}.
@end enumerate

@subsection aarch64-stivale2

Syscalls are invoked in Ironclad by using @code{swi}.

The index of the syscall is passed over @code{%x8}, while the return value is
returned in @code{%x0}, errno is returned in @code{%x9}, arguments are passed
over @code{%x0} to @code{r7}.

@subsection arm-raspi2b

Syscalls are invoked in Ironclad by using @code{swi}.

The index of the syscall is passed over @code{%r4}, while the return value is
returned in @code{%r0}, errno is returned in @code{%r1}, arguments are passed
over @code{%r0} to @code{r7}.

@subsection sparc-leon3

The syscall mechanism for leon3 is yet to be implemented. Sorry!

@subsection x86_64-multiboot2

Syscalls are invoked in Ironclad by using @code{syscall}.

The index of the syscall is passed over @code{%rax}, while the return value is
returned in @code{%rax}, errno is returned on @code{%rdx}, arguments are passed
over @code{%rdi}, @code{%rsi}, @code{%rdx}, @code{%r12}, @code{%r8},
@code{%r9}, and @code{%r10}, following the SysV ABI.

@node Errno
@section Errno

Errno are values returned by the kernel to detail the nature of an error in
depth. When a syscall does not error out, it returns the value 0 on the errno
field. Here is a table of all the possible errno and its values and meaning:

@table @code
@item ERANGE (3)
The passed value was not big enough.

@item EACCES (1002)
The passed access for a variable points to bad memory.

@item EAGAIN (1006)
The requested resource is not available at the moment.

@item EBUSY (1010)
The requested resource is busy and cannot handle the request.

@item ECHILD (1012)
The passed value is not a child process.

@item EFAULT (1020)
The passed value would make the program fault.

@item EFBIG (1021)
File too large, or an attempt to surpass the limit on file size was issued.

@item EINVAL (1026)
The passed value is not valid for the called syscall.

@item EIO (1027)
The requested operation failed at a device level.

@item EMFILE (1031)
Too many files were opened by the process.

@item ENAMETOOLONG (1036)
The passed value is too big for the syscall.

@item ENOENT (1043)
No such file or directory.

@item ENOSYS (1051)
The requested syscall or flag is not implemented.

@item ENOTTY (1058)
The passed argument is not a TTY.

@item ENOTSUPP (1060)
The passed argument is valid, but does not implement the operation. Mostly
used for sockets and other networking elements when dealing with protocols.

@item EPERM (1063)
Bad permissions.

@item ESPIPE (1069)
A seek was issued to an invalid device.

@item ESRCH (1070)
The passed item could not be found after a search.

@item EBADFD (1081)
The passed FD is in a bad state or invalid.

@end table

@node exit
@section exit

@example
void exit(uint64_t status);
@end example

This syscall terminates the calling process "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this, rookie mistake.
@end itemize

@node arch_prctl
@section arch_prctl

@example
int arch_prctl(int code, uint64_t argument);
@end example

This syscall interacts with architecture-specific thread-local storage. For
x86_64, these are the available codes:

@table @code
@item ARCH_SET_FS (1)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_FS (2)
Stores the current thread's FS into the variable pointed to by @code{argument}.

@item ARCH_SET_GS (3)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_GS (4)
Stores the current thread's GS into the variable pointed to by @code{argument}.
@end table

This syscall returns @code{0} on success, and @code{-1} on failure.
errno is to be set to the following values on failure:

@itemize @bullet
@item
@code{EINVAL}: @code{code} is not valid.

@item
@code{EFAULT}: @code{argument} is outside the available address space.
@end itemize

@node open
@section open

@example
int open(int dir_fd, char *path, int path_len, int flags);
@end example

@code{open} opens the passed file relative to @code{dir_fd}, depending on the
flags passed. It does not create the file if not existent. By default, the file
descriptor will remain open accross an @code{exec}.

@code{flags} can be an OR'd field of the following elements:

@table @code
@item O_RDONLY (0b000001)
Makes the file able to be read.

@item O_WRONLY (0b000010)
Makes the file able to be written to.

@item O_APPEND (0b000100)
Makes the file be opened at the end of the file, instead of the beggining.

@item O_CLOEXEC (0b001000)
Will make the file close when @code{exec}'d.

@item O_NOFOLLOW (0b0100000000)
Do not follow symlinks when opening the file.

@item O_NONBLOCK (0b1000000000)
Make the file not block on read or write operations when possible.
@end table

The syscall returns the opened file descriptor or @code{-1} on error, and errno
is set to the following:

@itemize @bullet
@item
@code{ENOENT}: The referenced file does not exist.

@item
@code{EINVAL}: Combination of @code{flags} is not valid.

@item
@code{EMFILE}: Too many files are already owned by the process.

@item
@code{EFAULT}: The passed path is outside the available address space.
@end itemize

@node close
@section close

@example
int close(int fd);
@end example

@code{close} closes an open file descriptor. Once no open references exist of a
file descriptor, its resources are freed, and the file deleted if needed.

The syscall returns 0 on success and -1 in failure, and errno is set to:

@itemize @bullet
@item
@code{EBADF}: The passed file to @code{close} is not valid.
@end itemize

@node read/write
@section read/write

@example
ssize_t read(int fd, void *buffer, size_t count);
ssize_t write(int fd, void *buffer, size_t count);
@end example

These syscalls attempts to read or write up to passed count from the passed file descriptor.

On files that support seeking, the operation commences at the file offset, and
the file offset is incremented by the number of bytes read or written. If the
file offset is at or past the end of file, no bytes are read or written, and
the operation returns zero.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed fd is not suitable for the operation.

@item
@code{EFBIG}: When writing, the issued write would surpass the process
file size limit.

@item
@code{EIO}: The requested operation failed at the device level.
@end itemize

@node seek
@section seek

@example
off_t seek(int fd, off_t offset, int whence);
@end example

This syscall repositions the file offset of the passed file description to the
passed offset according to the directive whence as follows:

@itemize @bullet
@item
@code{SEEK_SET} (1): Set to the passed offset.

@code{SEEK_CUR} (2): Set to the current offset plus the passed offset.

@code{SEEK_END} (4): Set to the size of the file plus the passed offset.
@end itemize

This syscall returns the resulting offset, or @code{-1} on failure. errno is to
be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EINVAL}: The whence is malformed or the resulting offset would be invalid.

@item
@code{ESPIPE}: @code{seek} was called on a TTY or a pipe.
@end itemize

@node mmap/mprotect/munmap
@section mmap/mprotect/munmap

@example
void *mmap(void *hint, size_t length, int protection, int flags, int fd,
   off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *address, size_t length);
@end example

@code{mmap} creates a new mapping in the virtual address space of the calling
process. An address can be passed, if it is @code{null}, then the kernel gets
to choose the address, else, it is taken as a hint about where to place the
mapping. If a section of the mapping overlaps an existing mapping, it will be
ignored.

@code{hint} and @code{length} are required to be aligned to page boundaries
for the running architecture, else it will fail.

@code{protection} and @code{flags} are a bitfield of the following flags:

@itemize @bullet
@item
@code{PROT_READ} (0b00001): Read permissions.

@item
@code{PROT_WRITE} (0b00010): Write permissions.

@item
@code{MAP_FIXED} (0b00100): Use hint as a hard requirement.

@item
@code{MAP_ANON} (0b01000): Mapping is not backed by any file.

@item
@code{MAP_WC} (0b10000): Map using write-combining when possible.
@end itemize

@code{munmap} will unmap a range for the virtual address space of the calling
process, this values must be the same as passed and returned by @code{mmap},
partial unmapping is allowed.

@code{mprotect} allows to change the permission of a range of memory of the
passed length pointed by @code{addr}, previously mapped by the caller.
The format of @code{prot} is the same as @code{mmap}.

@code{mmap} returns a pointer to the allocated area, or @code{-1} on failure.
@code{munmap} and @code{mprotect} both returns @code{0} on success and
@code{-1} on failure. All the functions set the following errno:

@itemize @bullet
@item
@code{EINVAL}: Bad hints or parameters.

@item
@code{ENOMEM}: The operation could not be completed due to a lack of memory.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getpid/getppid
@section getpid/getppid

@example
int getpid();
int getppid();
@end example

@code{getpid} returns the process ID (PID) of the calling process.
@code{getppid} does the same but it returns the one of the parent, which is the
process that created the callee by a myriad of ways.

This functions are always successful.

@node exec
@section exec

@example
int exec(const char *path, int path_len, char *const argv[], int argv_len, char *const envp[], envp_len);
@end example

This syscall executes the program passed with the passed argv and evp, closing
all the threads of the callee process and putting a single one in place for
the new program. Other process-specific elements like file descriptors are
untouched.

This syscall only returns in failure with @code{-1} with the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file passed in path doesnt exist.

@item
@code{EACCES}: The file couldn't be launched out of a permission error.
@end itemize

@node clone
@section clone

@example
#define CLONE_PARENT 0b01
#define CLONE_THREAD 0b10

pid_t clone(void *callback, uint64_t arg, void *stack, int flags, void *tls);
@end example

This syscall creates a new thread or process depending on @code{flags}.
@code{flags} can be an OR'd combination of the following flags:

@itemize @bullet
@item
@code{CLONE_PARENT} (0b01): The process or thread will be a child of the parent
of the caller process, instead of the caller process itself.

@code{CLONE_THREAD} (0b10): If set, a thread will be created and added to the
parent process, if not set, a process will be created instead. The child
process will only have the callee thread cloned. The other threads, if any,
are not cloned.
@end itemize

This syscall returns @code{0} on success for the child, and the children PID or
TID to the parent, in failure, the parent gets @code{-1} with the following
errno:

@itemize @bullet
@item
@code{EAGAIN}: The system could not create the entity right now, try again
later.

@item
@code{EINVAL}: @code{CLONE_PARENT} is specified and the caller process has no
parent.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node wait
@section wait

@example
pid_t wait(pid_t pid, int *status, int options);
@end example

This syscall suspends execution until the passed pid exits, to then store the
exit code in @code{status}.

@code{wait} allows the option @code{WNOHANG(0b000010)} for non-blocking
waiting, if the process has not finished yet, @code{0} will be returned.

@code{pid} can be a PID the callee is a parent of, or @code{-1} to wait on all
the PIDs the callee has as children. @code{0}, which waits on all the children
of a process group, is not implemented yet.

This syscall returns the PID waited on or @code{-1} on failure, along with the
following errno:

@itemize @bullet
@item
@code{ECHILD}: The passed PID does not exist.

@item
@code{EINVAL}: The passed options are not correct or the passed PID is @code{0}
@end itemize

@node socket
@section socket

@example
#define AF_UNIX       3
#define SOCK_DGRAM    0b000000000000000001
#define SOCK_RAW      0b000000000000000010
#define SOCK_STREAM   0b000000000000000100
#define SOCK_NONBLOCK 0b010000000000000000
#define SOCK_CLOEXEC  0b100000000000000000

int socket(int domain, int type, int protocol);
@end example

This syscall for creating sockets, the passed fields can be used for selecting
the type of socket to create. The available sockets type are:

@itemize @bullet
@item
@code{AF_UNIX (3)}: UNIX domain socket for local communication, this sockets
can be unnamed or bound to filesystem paths.

The address of a UNIX domain socket takes the shape of

@example
struct sockaddr_un @{
   uint32_t sun_family; // AF_UNIX.
   char path[];         // Must be null terminated.
@};
@end example

@code{type} can be one of @code{SOCK_DGRAM} or @code{SOCK_STREAM}. The
difference between eachother is that datagram sockets preserve message
boundaries while stream sockets work in streams of data, like a pipe would.
@end itemize

Any socket type may have @code{type} be OR'ed with @code{SOCK_NONBLOCK} or
@code{SOCK_CLOEXEC} for setting the created socket nonblock or cloese on exec
respectively.

The syscall returns the resulting FD or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid combination of flags.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node sethostname
@section sethostname

@example
int sethostname(const char *buffer, size_t length);
@end example

This syscall sets the kernel hostname to the passed string. @code{0} is
returned on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed buffer points to an invalid address.

@item
@code{EINVAL}: The passed length is bigger than the kernel can handle or 0.

@item
@code{EACCES}: MAC did not allow this.
@end itemize

@node unlink
@section unlink

@example
int unlink(int dir_fd, const char *path, int path_len);
@end example

The syscall queues for deletion the file pointed to by @code{path}. If
@code{path} points to a directory, it must be empty.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{ENOENT}: @code{delete} points to a file not valid for deletion, if at all.
@end itemize

@node fstat
@section fstat

@example
struct stat @{
    dev_t st_dev;
    ino_t st_ino;
    mode_t st_mode;
    nlink_t st_nlink;
    uid_t st_uid;
    gid_t st_gid;
    dev_t st_rdev;
    off_t st_size;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    blksize_t st_blksize;
    blkcnt_t st_blocks;
@};

int fstat(int dir_fd, char *path, int len, struct stat *statbuf,
   int flags);
@end example

This syscalls return information about a file, be it an already opened one with
@code{dir_fd} and @code{AT_EMPTY_PATH} in @code{flags}, or by relatively
opening, either following or not following symlinks with
@code{AT_SYMLINK_NOFOLLOW}.

@code{0} is returned on success, @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The passed path or file descriptor is not valid.

@item
@code{ENOENT}: The file pointed by @code{path} does not exist.

@item
@code{EFAULT}: The passed address for the path or stat buffer is not valid.
@end itemize

@node chdir
@section chdir

@example
int chdir(int fd);
@end example

This syscalls will set the callee's process current working directory to
the passed FD, which must point to a directory.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EBADFD}: The passed descriptor is not a valid directory.
@end itemize

@node ioctl
@section ioctl

@example
int ioctl(int fd, unsigned long request, void *argument);
@end example

This syscall manipulates the underlying device parameters of special files. It
allows a device-dependent API for fetching and setting several modes.

Despite not all ioctl calls needing a specific value for their arguments, due
to current limitations, all arguments must point to valid memory, regardless
of whether it ends up used or not.

@code{ioctl} returns @code{0} on success and @code{-1} on failure, and sets the
following errno:

@itemize @bullet
@item
@code{ENOTTY}: The passed file does not support the passed ioctl.

@item
@code{EBADF}: The passed file does not exist for the process.

@item
@code{EFAULT}: The passed argument is in non-accesible memory
@end itemize

@node sched_yield
@section sched_yield

@example
int sched_yield(void);
@end example

This syscall relinquishes execution of the caller thread.
Its up for the kernel how far in the queue of execution this thread will go.

This syscall returns @code{0} always, as it never fails, this is done for
compatibility with POSIX instead of having a @code{void} return type.

@node delete_tcluster
@section delete_tcluster

@example
int delete_tcluster(int cluster);
@end example

This syscall deletes the passed thread cluster, will only succeed if the
cluster has no associated threads.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: The passed cluster does not exist or still has threads.
@end itemize

@node pipe
@section pipe

@example
int pipe(int pipefd[2], int flags);
@end example

This syscalls creates a pipe with the passed flags and returns the registered
file descriptors in @code{pipefd}. Index @code{0} is the reader end, @code{1}
is the writing one.

The only available flag for use is @code{O_NONBLOCK}.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{pipefd} points to bogus memory.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node rename
@section rename

@example
#define RENAME_NOREPLACE 1
int rename(int sourcedirfd, const char *sourcepath, size_t sourcelen,
       int targetirfd, const char *targetpath, size_t targetlen, int flags);
@end example

This syscalls renames a file in an atomic operation, it is only available in
between files in the same mountpoint. If @code{targetpath} exists, it will be
replaced, @code{RENAME_NOREPLACE} may be passed in @code{flags} for making the
call fail in said case instead of replacing silently.

The syscall return the new fd on success and @code{-1} on failure. The errno
codes set on failure are:

@itemize @bullet
@item
@code{EFAULT}: One of the passed values is outside addressable memory.

@item
@code{ENAMETOOLONG}: The passed path is too long.

@item
@code{EIO}: The operation could not be done out of an internal error.
@end itemize

@node sysconf
@section sysconf

@example
#define SC_PAGESIZE       1 // Page size of the system.
#define SC_OPEN_MAX       2 // Maximum amount of files per process.
#define SC_HOST_NAME_MAX  3 // Maximum length of hostnames.
#define SC_AVPHYS_PAGES   4 // Number of free physical pages.
#define SC_PHYS_PAGES     5 // Number of total available pages.
#define SC_NPROC_ONLN     6 // Number of processors active and used.
#define SC_TOTAL_PAGES    7 // Total amount of installed memory pages.
#define SC_LIST_PROCS     8 // List all processes of the system.
#define SC_LIST_MOUNTS    9 // List all mountpoints of the system.
#define SC_UNAME         10 // Fetch basic system information.
#define SC_CHILD_MAX     11 // Maximum number of children for the user.
#define SC_LIST_THREADS  12 // List all threads of the system.
#define SC_LIST_CLUSTERS 13 // List all thread clusters of the system.

long int sysconf(int request, uintptr_t addr, uintptr_t len);
@end example

This syscalls fetches the requested information in @code{request} and returns
it.

Depending on the request, @code{addr} and @code{len} may be used for
determining the address of a buffer and its length for reporting information
that doesn't fit on the usual return value. The options where they have meaning
are:

@itemize @bullet
@item
@code{SC_LIST_PROCS}: @code{addr} points to an array of items, and @code{len}
is the count of bytes reserved in the array. The items have the structure:

@example
struct procinfo @{
    char id[20];
    uint16_t id_len;
    uint16_t ppid;
    uint16_t pid;
    uint32_t uid;
    uint32_t flags;
@} __attribute__((packed));
@end example

The total number of processes is returned, even if it doesnt fit in the passed
array.

@item
@code{SC_LIST_MOUNTS}: @code{addr} points to an array of items, and @code{len}
is the count of bytes reserved in the array. The items have the structure:

@example
struct mountinfo @{
    uint32_t fs_type;
    uint32_t flags;
    char source[20];
    uint32_t source_len;
    char location[20];
    uint32_t location_len;
@};
@end example

The total number of mounts is returned, even if it doesnt fit in the passed
array.

@item
@code{SC_UNAME}: @code{addr} points to the following structure, and @code{len}
is the length in bytes of said structure:

@example
struct utsname @{
    char sysname[65];  // Kernel name (e.g., "Ironclad")
    char nodename[65]; // Hostname of the machine.
    char release[65];  // Kernel release (e.g., "2.6.28")
    char version[65];  // Kernel release, again.
    char machine[65];  // Hardware identifier (e.g., "x86")
@};
@end example

In success, the returned value will be @code{0}.

@item
@code{SC_LIST_THREADS}: @code{addr} points to an array of items, and @code{len}
is the count of bytes reserved in the array. The items have the structure:

@example
struct threadinfo @{
    uint16_t tid;
    uint16_t tcid;
    uint16_t pid;
@};
@end example

The total number of threads is returned, even if it doesnt fit in the passed
array.

@item
@code{SC_LIST_CLUSTERS}: @code{addr} points to an array of items, and
@code{len} is the count of bytes reserved in the array. The items have the
structure:

@example
struct tclusterinfo @{
    uint16_t tcid;
    uint16_t tflags;
    uint16_t tquantum;
@};
@end example

The total number of thread clusters is returned, even if it doesnt fit in the
passed array.
@end itemize

The syscall return the requested information on success and @code{-1} on
failure. If the requested value can also be @code{-1}, errno must be checked.

The errno codes set on failure are:

@itemize @bullet
@item
@code{EINVAL}: Invalid request.
@end itemize

@node spawn
@section spawn

@example
pid_t spawn(const char *path, int path_len, char *const argv[],
   int argv_len, char *const envp[], int envp_len, uint64_t *caps);
@end example

This syscall spawns a child process in a way similar to what a
@code{clone}+@code{exec} could be used for, but more efficiently, given it
doesn't need to copy the address space just to overwrite it, and only forking
the first 3 standard file descriptors instead all of them.

The argument @code{caps}, if not @code{NULL}, points to a capability set in
the same format as @ref{mac_capabilities}. This can be useful for deescalating
capabilities in the same convenient way as a call to @code{mac_capabilities} in
between @code{clone} and @code{exec} could.

The syscall returns the created PID on success and @code{0} on failure, with
the errno codes being:

@itemize @bullet
@item
@code{EAGAIN}: The system could not create the process right now.

@item
@code{EFAULT}: One or more of the passed arguments point to invalid memory.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node gettid
@section gettid

@example
int gettid(void);
@end example

This syscall returns the current thread id. It never fails.

@node manage_tcluster
@section manage_tcluster

@example
#define SCHED_RR   0b001
#define SCHED_COOP 0b010
#define SCHED_INTR 0b100

int manage_tcluster(int cluster, int flags, int quantum, int percentage);
@end example

This syscall sets settings for the passed cluster.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow the operation.
@item
@code{EINVAL}: One of the passed values was not correct.
@end itemize

@node fcntl
@section fcntl

@example
#define FD_CLOEXEC      1
#define F_DUPFD         1
#define F_DUPFD_CLOEXEC 2
#define F_GETFD         3
#define F_SETFD         4
#define F_GETFL         5
#define F_SETFL         6
#define F_GETPIPE_SZ    7
#define F_SETPIPE_SZ    8

int fcntl(int fd, int cmd, int arg);
@end example

This syscall is a multiplexed syscall that performs the operations described
below on the open file descriptor @code{fd}. The operation is determined by
@code{cmd} and may take an optional argument @code{arg}.

The syscall's return value will depend on the requested @code{cmd}, and is
detailed along the operations below.

The valid operations are:

@itemize @bullet
@item
@code{F_DUPFD}: Clones @code{fd} into a the first available file descriptor
starting by @code{arg}. Returns the resulting FD.

@item
@code{F_DUPFD_CLOEXEC}: The same as @code{F_DUPFD} but sets the close on exec
flag for the cloned FD if succesful, in order to save a subsequent call.

@item
@code{F_GETFD}: The flags used for @code{fd} will be returned, right now
only @code{FD_CLOEXEC} is supported. The syscall will return the flags on
success.

@item
@code{F_SETFD}: The flags for @code{fd} will be set with @code{arg}. The
syscall will return @code{0} on sucess.

@item
@code{F_GETFL}: Returns as the function result the file access mode
and status flags.

@item
@code{F_SETFL}: What @code{F_SETFD} is to @code{F_GETFD} for
@code{F_GETFL}.

@item
@code{F_GETPIPE_SZ}: If @code{fd} points to a FIFO or pipe, return
its size.

@item
@code{F_SETPIPE_SZ}: If @code{fd} points to a FIFO or pipe, the size will
be set to the value of @code{arg}. If the operation would cause data loss, it
will fail.
@end itemize

On failure, the syscall returns @code{-1}. The returned @code{errno} are:

@itemize @bullet
@item
@code{EINVAL}: The passed @code{cmd} is not implemented by the kernel.

@item
@code{EBADF}: The passed @code{fd} is not open.
@end itemize

@node exit_thread
@section exit_thread

@example
void exit_thread(void);
@end example

This syscall terminates the calling thread "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getrandom
@section getrandom

@example
ssize_t getrandom(void *buffer, size_t length);
@end example

This syscall fills the buffer pointed to @code{buffer} with up to @code{length}
random bytes. These bytes can be used for cryptographic purposes.

The operation is the same as reading from @code{/dev/random}. It is provided
instead of just reading from the device as to avoid denial of service attacks
based on exhausting the file descriptor limit of the system, along with other
vulnerabilities and inconveniences related to the classic file interface.

The syscall returns the count of read random data or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{buffer} points to invalid memory.
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node mac_capabilities
@section mac_capabilities

@example
#define MAC_CAP_SCHED   0b00000000001
#define MAC_CAP_SPAWN   0b00000000010
#define MAC_CAP_ENTROPY 0b00000000100
#define MAC_CAP_SYS_MEM 0b00000001000
#define MAC_CAP_USE_NET 0b00000010000
#define MAC_CAP_SYS_NET 0b00000100000
#define MAC_CAP_SYS_MNT 0b00001000000
#define MAC_CAP_SYS_PWR 0b00010000000
#define MAC_CAP_PTRACE  0b00100000000
#define MAC_CAP_SETUID  0b01000000000
#define MAC_CAP_SYS_MAC 0b10000000000

unsigned long get_mac_capabilities(void);
int set_mac_capabilities(unsigned long request);
@end example

These syscalls allow to fetch and set MAC capabilities on the way described in
@ref{Mandatory access control (MAC)}.

Both syscalls cannot fail, @code{get_mac_capabilities} always returns the
capabilities of the callee process and @code{set_mac_capabilities} always
returns @code{0}, settings will just be ignored if permission to change them
is not granted.

@node add_mac_permissions
@section add_mac_permissions

@example
#define MAC_PERM_CONTENTS 0b0000001
#define MAC_PERM_READ     0b0000010
#define MAC_PERM_WRITE    0b0000100
#define MAC_PERM_EXEC     0b0001000
#define MAC_PERM_APPEND   0b0010000
#define MAC_PERM_FLOCK    0b0100000
#define MAC_PERM_DEV      0b1000000

int add_mac_permissions(const char *path, int flags);
@end example

This syscall adds permissions to access an inode or device as described in
@ref{Mandatory access control (MAC)}.

If @code{MAC_PERM_DEV} is used in @code{flags}, @code{path} must be the name
of a device, without @code{/dev/}, else, it will be taken as a VFS inode. The
other flags reflect permissions given to the added device or inode. All of them
do not conflict.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EPERM}: MAC did not allow this.
@item
@code{EFAULT}: The passed pointer does not point to valid memory.
@item
@code{EAGAIN}: The system has reached a limit on registered rules.
@item
@code{EINVAL}: The passed rule is already covered or conflicts with an existent
one.
@end itemize

@node set_mac_enforcement
@section set_mac_enforcement

@example
#define MAC_DENY            0b001
#define MAC_DENY_AND_SCREAM 0b010
#define MAC_KILL            0b100

int set_mac_enforcement(unsigned long request);
@end example

This syscall sets the action to take for enforcement on MAC issues as explained
in @ref{Mandatory access control (MAC)}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC was locked.
@end itemize

@node mount/umount
@section mount/umount

@example
#define MNT_FAT   1
#define MNT_EXT   2
#define MS_RDONLY 1

#define MNT_FORCE 1

int mount(const char *source, int source_len, const char *target,
          int target_len, int fs_type, unsigned long flags);
int umount(const char *target, int target_len, int flags);
@end example

These syscalls mount and unmount filesystems. For @code{mount}, @code{source}
is the source device while @code{target} is where to mount in the
global virtual filesystem. For @code{umount}, @code{target} is the path to
unmount.

For @code{mount}, @code{fs_type} can be one of the following values to choose
the filesystem type to mount, it must be specified, detection is not done.

@itemize @bullet
@item
@code{MNT_FAT}: FAT family filesystem.
@item
@code{MNT_EXT}: EXT family filesystem.
@end itemize

@code{flags} may contain @code{MS_RDONLY} to force mounting read-only mounting.

For @code{umount}, @code{flags} allows the following options:

@itemize @bullet
@item
@code{MNT_FORCE}: Unmount the filesystem even if busy, can cause data loss.
@end itemize

These syscalls returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: Wrong arguments.
@item
@code{EBUSY}: For @code{umount}, the mount is busy, and @code{MNT_FORCE} was
not passed.
@end itemize

@node readlink
@section readlink

@example
ssize_t readlink(char *path, int path_len, char *buffer, size_t buffer_len);
@end example

The syscall reads the redirected path of a symlink.

The syscalls return the read length on success or @code{-1} on failure, with
the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: The passed file is not a symbolic link.
@end itemize

@node getdents
@section getdents

@example
#define DT_UNKNOWN 0
#define DT_FIFO    1
#define DT_CHR     2
#define DT_DIR     4
#define DT_BLK     6
#define DT_REG     8
#define DT_LNK    10
#define DT_SOCK   12
#define DT_WHT    14

struct dirent @{
   uint64_t d_ino;
   uint64_t d_off;
   uint16_t d_reclen;
   uint8_t  d_type;     // One of the DT_ values.
   char     d_name[61]; // Null-terminated.
@};

ssize_t getdents(int fd, struct dirent *buffer, size_t size);
@end example

This syscall reads the contents of the passed directory, and advances the
file position for the directory by the amount of read directory entries.
Partial reads are supported.

The syscalls return the read length in bytes on success, or @code{0} if no
contents or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the arguments.
@item
@code{EBADFD}: @code{fd} does not contain a valid file.
@item
@code{ENOENT}: @code{fd} is not a directory.
@item
@code{EINVAL}: @code{size} is not big enough to fit all the directory entries.
@end itemize

@node sync
@section sync

@example
int sync(void);
@end example

The syscall flushes the associated caches of all FSes and the devices that
contain said FSs, ensuring that all operations are finished, this can be used
in order to ensure data coherency on power loss or program failure.

The syscall returns @code{0} or @code{-1} on failure, with a corresponding
errno:

@itemize @bullet
@item
@code{EIO}: Device error while flushing.
@end itemize

@node mknod
@section mknod

@example
int mknod(int dir_fd, const char *path, int path_len, int mode, int dev);
@end example

This syscall creates files in the passed path and dir. The type is chosen by
@code{code}, which uses the same format as @code{stat}'s mode field.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path length is way too big, or the mode is invalid.
@item
@code{EIO}: Internal error.
@end itemize

@node truncate
@section truncate

@example
int truncate(int fd, uint64_t new_size);
@end example

The syscall truncates the size of @code{fd} on disk to exactly @code{new_size}
bytes.

If the file was larger, the cropped contents are lost, if it was smaller, the
new data is zero'd out. No other file data is changed.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The file pointed by @code{fd} is not valid for truncation.
@item
@code{EINVAL}: @code{new_size} could not be set.
@end itemize

@node bind
@section bind

@example
struct sockaddr @{
   uint32_t sun_family; // AF values of socket().
   char data[];
@};

int bind(int sockfd, const struct sockaddr *addr, unsigned int addrlen);
@end example

This syscall assigns a global address to the passed socket, the meaning and
nature of the address depends on the passed socket.

The actual structure passed for the @code{addr} argument will depend on
the address family, @code{sockaddr} is a catch-all placeholder value.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid address, may be already in use.
@item
@code{EFAULT}: Bad memory address.
@item
@code{EBADFD}: The passed FD is not a socket.
@end itemize

@node mkdir
@section mkdir

@example
int mkdir(int dir_fd, const char *path, int path_len, int mode);
@end example

This syscall creates directories in the passed path.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path length is way too big.
@item
@code{EIO}: Internal error.
@end itemize

@node symlink
@section symlink

@example
int symlink(int dir_fd, const char *path, int path_len,
            const char *target, int target_len, int mode);
@end example

This syscall creates symlinks for the passed path and mode.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path and target lengths are way too big, or the
passed mode is invalid.
@item
@code{EIO}: Internal error.
@end itemize

@node connect
@section connect

@example
int connect(int sockfd, const struct sockaddr *addr, unsigned int addrlen);
@end example

This syscall connects the passed socket to the passed global address.

If the passed socket is datagram-based, then @code{addr} is the address to
which datagrams are sent by default, and the only address from which datagrams
are received. If the socket is stream-based, the syscall attempts to make a
connection to the socket that is bound to the address specified by @code{addr}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid address, may not be bound.
@item
@code{EFAULT}: Bad memory address.
@item
@code{EBADFD}: The passed FD is not a socket.
@end itemize

@node openpty
@section openpty

@example
int openty(int ptys[2], struct termios *t, struct win_size *w);
@end example

This syscalls creates a pair of pseudoterminals and returns the registered
file descriptors in @code{ptys}. Index @code{0} is the primary end
(also known as master), @code{1} is the secondary end (also known as slave).

@code{t} and @code{w} are the termios and window information the created
pseudoterminals will contain.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{ptys}, @code{t}, or @code{w}, point to bogus memory.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node fsync
@section fsync

@example
int fsync(int fd, int flags);
@end example

The syscall does the same as @code{sync}, just only applied to @code{fd}. If
the passed file is a device, the device will flush its internal caches.

If the file was just created, one might considering synchronizing the parent
directory as well, as, depending on the FS and FS driver, parent directory
entries are stored separately to the file, EXT-series filesystems come to mind.

If @code{flags} is not zero, only the data of the passed descriptor will be
guaranteed to be flushed, and not modified metadata, this can be used in
order to minimize disk activity even further.

The syscall returns @code{0} or @code{-1} on failure, with the errno:

@itemize @bullet
@item
@code{EBADF}: The passed file is not open.
@item
@code{EINVAL}: The passed points to a non-synchronizable entity.
@item
@code{EIO}: FS or device error while flushing.
@end itemize

@node link
@section link

@example
int link(int dir_fd, const char *path, int path_len,
         const char *target, int target_len);
@end example

This syscall creates hard links, the paths are not dereferenced in the case
of being symlinks.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path and target lengths are way too big.
@item
@code{EIO}: Internal error.
@end itemize

@node ptrace
@section ptrace

@example
#define PTRACE_SYSCALL_PIPE 1

long ptrace(long request, pid_t pid, void *addr, void *data);
@end example

This syscall can be used for tracing, debugging, execution control, and info
reporting of data owned by a child process. The operations is indicated by
@code{request}, while the PID to act upon is @code{pid}, @code{addr} the
address in the child process to modify, and @code{data} what to modify with.

@code{request} can be one of:

@itemize @bullet
@item
@code{PTRACE_SYSCALL_PIPE (1)}: @code{data} will be taken as an FD in the
child process, which the kernel will use to report the state on every syscall
the child process does. The descriptor must be a pipe, no other files are
supported. Errors writing are silently ignored.
@end itemize

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow this.
@item
@code{EPERM}: @code{pid} is not a child or does not exist.
@item
@code{EINVAL}: @code{request} is not valid.
@end itemize

@node listen
@section listen

@example
int listen(int sockfd, int backlog);
@end example

This syscall marks the passed socket as a passive socket, that is, as a socket
that will be used to accept incoming connection requests using @code{accept}.

The passed socket must be stream based, as these are the only sockets with a
true sense of connection.

@code{backlog} is a recommendation as to the maximum length to which the
queue of pending connections for @code{sockfd} may grow. If a connection
request arrives when the queue is full, depending on the protocols involved,
the client may receive an error or the connection may be ignored so that a
later reattempt at connection succeeds.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid value for backlog.
@item
@code{EBADFD}: The passed FD is not a socket.
@item
@code{ENOTSUPP}: The passed FD is a socket, but it is not a stream socket.
@end itemize

@node accept
@section accept

@example
int accept(int sockfd, const struct sockaddr *addr, int *addrlen, int flags);
@end example

This syscall takes the first connection request of @code{sockfd} and creates
a new connected socket with the flags in @code{flags} (@code{SOCK_NONBLOCK} and
@code{SOCK_CLOEXEC}). @code{addr} is used for writing the address of the
connection request. @code{addrlen} must be the length of the available buffer,
and it will be written to be the actual length copied.

The syscall returns the added FD on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid value for backlog.
@item
@code{EBADFD}: The passed FD is not a socket and listening.
@item
@code{ENOTSUPP}: The passed FD is a socket, but it is not a stream socket.
@end itemize

@node getrlimit/setrlimit
@section getrlimit/setrlimit

@example
#define RLIMIT_CORE   1 // Size of core files, 0 for disabling.
#define RLIMIT_CPU    2 // CPU time limit in seconds.
#define RLIMIT_DATA   3 // Data segment size in bytes.
#define RLIMIT_FSIZE  4 // Maximum file size in bytes.
#define RLIMIT_NOFILE 5 // Maximum number of open file descriptors.
#define RLIMIT_STACK  6 // Maximum stack size in bytes.
#define RLIMIT_AS     7 // Maximum memory size in bytes.

uint64_t getrlimit(int resource);
int setrlimit(int resource, uint64_t limit);
@end example

This syscall fetches and sets current limits for a specified resource, limits
can only be lowered, are inherited from parent to children, and start
maxed out.

When a limit is reached, the operation that would reach or exceed it will fail
like the following:

@itemize @bullet
@item
@code{RLIMIT_CORE}: Core files exceeding this size will be truncated, with 0,
core files are not generated.
@item
@code{RLIMIT_CPU}: Once the limit is passed, the process is killed.
@item
@code{RLIMIT_DATA}: @code{mmap} or other allocation syscalls will fail with
@code{ENOMEM}.
@item
@code{RLIMIT_FSIZE}: System call growing the file fails with @code{EFBIG}.
@item
@code{RLIMIT_NOFILE}: Adding a new file descriptor fails with @code{EMFILE}.
@item
@code{RLIMIT_STACK}: The operation will fail, and a @code{SIGSEGV} will be
generated.
@item
@code{RLIMIT_AS}: Same as @code{RLIMIT_DATA}.
@end itemize

@code{setrlimit} returns @code{0} on success or @code{-1} on failure. For
@code{getrlimit}, @code{0} is a valid return so checking errno is necessary.
Both report the following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid value for resource.
@item
@code{EPERM}: MAC did not allow the operation.
@end itemize

@node access
@section access

@example
#define F_OK 0b0001
#define R_OK 0b0010
#define W_OK 0b0100
#define X_OK 0b1000

#define AT_EACCESS 512

int access(int dir_fd, char *path, int len, mode_t mode, int flags);
@end example

This syscall whether the callee process can access the passed file against
POSIX file permissions and Ironclad's MAC. What to check for is specified in
@code{mode} as an ORd list, as such:

@itemize @bullet
@item
@code{F_OK}: When passed, only file existance will be checked.
@item
@code{R_OK}: When passed, read permissions will be checked.
@item
@code{W_OK}: When passed, write permissions will be checked.
@item
@code{X_OK}: When passed, execute permissions will be checked.
@end itemize

Permissions are checked with the real user and group IDs, instead of the
effective ones, that behaviour can be changed by passing @code{AT_EACCESS} in
@code{flags}, which can also be used for other common AT flags.
@code{AT_EMPTY_PATH} is not accepted because that does not make any sense with
this syscall.

The syscall returns @code{0} on success when the passed mode is checked valid,
or @code{-1} on check failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: @code{dirfd} is not valid.
@item
@code{ENOENT}: The requested file does not exist.
@item
@code{EACCES}: The access is not allowed.
@end itemize

@node poll
@section poll

@example
#define POLLIN   0b00000001
#define POLLOUT  0b00000010
#define POLLERR  0b00001000
#define POLLHUP  0b00010000
#define POLLNVAL 0b01000000

struct pollfd @{
   uint32_t fd;
   uint16_t events;
   uint16_t revents;
@};

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
@end example

This syscall allows to wait for a series of events to happen to the passed
FDs, in a manner similar to POSIX's @code{select}.

@code{fds} is an array of @code{nfds} length of @code{pollfd} structures. Each
structure represents one FD, for which @code{events} is a list of events
to wait for and @code{revents} is a bitmap written by the kernel to indicate
which events of the waited ones did happen. If the FD of an structure is
negative, that is, it has the first bit set, it is ignored, and @code{revents}
is set to @code{0}.

Both @code{events} and @code{revents} are bitmaps of the values:

@table @code
@item POLLIN
The passed FD has data pending for reading.

@item POLLOUT
The passed FD will not block when written to (a sensible amount).

@item POLLERR
Only for @code{revents}, it is set in the case of error waiting, or if the FD
is a pipe and the connection is broken, or if the passed FD is valid but does
not support poll operations.

@item POLLHUP
Only for @code{revents}, it is set in the case of the passed FD having lost
connection, or the FD being a broken pipe.

@item POLLNVAL
Only for @code{revents}, equivalent of @code{EBADFD}, that is, the passed FD
is not valid.
@end table

@code{timeout} argument specifies the number of milliseconds that the syscall
should block waiting for a file descriptor to become ready. The call will block
until either a file descriptor gets an event, the call is interrupted by a
signal handler, or the timeout expires.

The syscall returns the number of FDs to have an event happen on success or
@code{-1} on failure, with the following errno:

@table @code
@item EFAULT
The passed pointers are not in addressable memory.

@item EINVAL
The passed values are not valid.
@end table

@node getuid/geteuid
@section getuid/geteuid

@example
uid_t getuid(void);
uid_t geteuid(void);
@end example

These syscalls fetch the UID and the effective UID of the calling process. They
never fail.

@node setuids
@section setuids

@example
int setuids(uid_t uid, uid_t euid);
@end example

This syscall sets the UID and effective UID of the calling process, if any
of them is @code{-1}, it will not be set. @code{MAC_CAP_SETUID} is required
for this operation.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed values are not valid, or out of range.

@item EACCES
MAC did not allow this.
@end table

@node fchmod
@section fchmod

@example
int fchmod(int dir_fd, char *path, int len, mode_t mode, int flags);
@end example

This syscall sets the mode for the passed arguments in the same way
@ref{fstat} fetches information for the passed arguments.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD or mode is not valid.

@item EACCES
MAC did not allow this.
@end table

@node umask
@section umask

@example
mode_t umask(mode_t mask);
@end example

This syscall sets the umask of the calling process to the passed mask AND'd
with @code{777} in octal.

The umask is used by the kernel when creating files in the name of the calling
process. It marks permissions to be turned off from @code{mode} arguments
passed by the user. The default value is @code{22} in octal, and is inherited
from parent processes to children.

This syscall never fails, it always returns the old mask before modification.

@node reboot
@section reboot

@example
#define RB_HALT     1
#define RB_POWEROFF 2
#define RB_RESTART  3
#define RB_ERROR_RET 0b1

int reboot(int cmd, int flags);
@end example

This syscall does the passed action to the system's power management, the
action is specified with @code{cmd}, it can be one of:

@table @code
@item RB_HALT
System activity is terminated and the system will make all needed preparations,
but power will not be cut off, instead, the user will have to do so, say, with
the power button. Data syncing is up to the user.

@item RB_POWEROFF
The same as @code{RB_HALT} but actually cuts power.

@item RB_RESTART
The same as @code{RB_HALT} but at the end, the system will reboot.
@end table

If the operation fails internally, for any reason, the kernel will panic, for
returning an error instead, one can use @code{RB_ERROR_RET} in @code{flags}.

This syscall does not return on success, it will only return in the case of
invalid value for @code{cmd}, before comitting to an operation, or by using
@code{RB_ERROR_RET} as previously said. In error, @code{-1} will be returned,
and errno will be set to:

@table @code
@item EINVAL
The passed @code{cmd} is not valid.

@item EACCES
MAC did not allow this.

@item EIO
The operation failed internally.
@end table

@node fchown
@section fchown

@example
int fchown(int dir_fd, char *path, int len, uint32_t user, uint32_t group,
   int flags);
@end example

This syscall sets the owner's UID and GID for the passed arguments in the same
way @ref{fstat} fetches information for the passed arguments.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD or the user and group were not valid.

@item EACCES
MAC did not allow this.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node pread/pwrite
@section pread/pwrite

@example
ssize_t pread(int fd, void *buffer, size_t count, off_t offset);
ssize_t pwrite(int fd, void *buffer, size_t count, off_t offset);
@end example

These syscalls do the same as @code{read} and @code{write} respectively, but
instead of using the description's saved location for data access, they use the
passed @code{offset}, and do not update it at the end of the operation.
@code{fd} must point to a seekable file.

These syscalls are made for use in multithreaded applications, as having more
than one thread updating file locations for a shared file description can lead
to sudden catharsis.

These syscalls return the same values and errno as the non-p variants.
@ref{read/write}.

@node getsockname
@section getsockname

@example
int getsockname(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen);
@end example

This syscall fetches the address of an already bound socket.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD was a non bound socket.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node getpeername
@section getpeername

@example
int getpeername(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen);
@end example

This syscall fetches the address of a socket's peer.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD was a non bound socket.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node shutdown
@section shutdown

@example
#define SHUT_RD   0b01
#define SHUT_RDWR 0b10
#define SHUT_WR   0b11

int shutdown(int sockfd, int how);
@end example

This syscall stops transmission or reception for a socket from a peer.

@code{how} signals how to stop communication, it can be the following values:

@table @code
@item SHUT_RD
Further receiving will not be allowed.

@item SHUT_WR
Further transmitting will not be allowed.

@item SHUT_RDWR
Further receiving and transmitting will not be allowed.
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD was a non bound socket.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node Filesystem support and interfaces
@chapter Filesystem support and interfaces

Ironclad's VFS is pretty barebones, so some features are not supported quite
well yet. Some of the affected features are:

@itemize @bullet
@item
Mountpoints may not be visible when contained within another mountpoint.
@item
Symbolic links do not work accross mount points, just like hard links.
@end itemize

Support for several filesystems is provided, with filesystem-specific quirks at
times, and exposes interfaces with @code{ioctl} calls.

@node Extended FileSystem
@section Extended FileSystem

Ironclad supports EXT-series filesystems read-only and read-write.

While a user may be used to the ext2/3/4 distinction, EXT internally works as
an independent set of features, with the version numbers specifying a
widely understood, assumed, and inconsistent set of features.

Ironclad supports the feature list: @code{sparse_super}, @code{large_file},
@code{filetype}, @code{resize_inode}, @code{dir_index}, @code{ext_attr}.

Those features should translate to ext2 read-write support, and ext3 read-only
support.

Some @code{ioctl} calls exist for files inside EXT-series FSs, which can help
manage specialized FS-specific inode flags and permissions, they are:

@example
EXT_GETFLAGS = 0x5600
EXT_SETFLAGS = 0x5601

ioctl(fd, EXT_GETFLAGS, pointer_to_u32); // Get EXT's flags inode field.
ioctl(fd, EXT_SETFLAGS, pointer_to_u32); // Set EXT's flags inode field.
@end example

@node File Allocation Table
@section File Allocation Table

Ironclad's FAT support is really rough. Only read-only FAT32 is supported.
No special @code{ioctl} calls are provided. Long filenames are not supported.

@node QNX4 FileSystem
@section QNX4 FileSystem

Stubbed, please ignore!

@node Devices and their properties
@chapter Devices and their properties

Ironclad exposes a number of physical and virtual devices to userland. All
of them are exposed under the @code{/dev} location, and support a series of
standard operations, like being manipulated by the usual file-related
syscalls like @code{read} or @code{write}, while sporting device-specific
interfaces in the form of device-specific @code{ioctl} requests.

When quering device-specific information, Ironclad exposes information a bit
different than other kernels like Linux. Here is a quick list of the most
notable differences:

@itemize @bullet
@item
The @code{BLKGETSIZE}/@code{BLKGETSIZE64} @code{ioctl} calls are not available,
instead, the block count and block size values of @code{stat} are used.
@end itemize

@node Common devices
@section Common devices

These are devices exposed in Ironclad regardless of target system when
present, with standardized interfaces.

@subsection debug

@code{/dev/debug} wraps architecture-specific debug output channels for use
with file operations. For x86-based targets, this is COM0, for ARM-based
and SPARC-based targets, this is UART.

@subsection ramdev

The devices starting by @code{ramdev} are virtual devices representing the
RAM driver passed by some boot protocols, an FS can be mounted to them, or be
otherwise used like any other block device. These RAM devices are read-only.

@subsection random

The device @code{random} is equivalent to the one featured in other unix-like
kernels. Keep in mind that Ironclad has limited sources of entropy, so the
quality of this random numbers is a bit limited. Writing to the source is not
allowed, unlike other systems.

@code{/dev/urandom} does the same as @code{/dev/random}, and is only provided
for compatibility.

@code{getrandom} is provided as well for avoiding the file interface, and that
way avoid certain kinds of DoS attacks.

@subsection null/zero

@code{null} returns @code{EOF} whenever read, and all the write operations are
discarded.

@code{zero} returns exclusively a stream of zeros when read, and all write
operations are discarded.

@subsection rtc

@code{/dev/rtc} exposes the hardware RTC in an architecture independent manner.

The device does not allow any file operations but the following @code{ioctl}:

The time structures handled represent ready-to-use, calendar timestamps.

@example
RTC_RD_TIME  = 1 // Reads time to the passed structure.
RTC_SET_TIME = 2 // Sets the RTC to the passed time.
struct rtc_time @{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;     /* unused */
    int tm_yday;     /* unused */
    int tm_isdst;    /* unused */
@};

ioctl(rtc, ..., pointer_to_rtc_time)
@end example

@node aarch64-stivale2 devices
@section aarch64-stivale2 devices

@subsection pl011

The device @code{pl011} supports read operations for PL011 UART compatible
devices.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented, only the ones related to input stream
settings.

The default baud for the device is set to be @code{115200}.

@node arm-raspi2b devices
@section arm-raspi2b devices

@subsection uart

@code{uart} supports read and write operations for the PL011 UART device
featured on the board on GPIOs 14 and 15 (pins 8 and 10).

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented, only the ones related to input stream
settings.

The default baud for the device is set to be @code{115200}.

@subsection watchdog

@code{watchdog} represents the hardware watchdog included with the board.
Writing to it will reset it, @code{ioctl} operations may be used for
timeout configuration and starting/stopping it.

@node sparc-leon3 devices
@section sparc-leon3 devices

This target has no special devices.

@node x86_64-multiboot2 devices
@section x86_64-multiboot2 devices

@subsection ata

The devices starting by @code{sata} represent several ATA IDE block devices.
These ATA drives have internal caching at the driver level, so they must be
@code{sync}'d for data integrity when wanting to ensure data coherency.

No special @code{ioctl} calls are supported.

@subsection fb0

The @code{fb0} device exposes the framebuffer passed as part of the boot
protocol, when present. The device uses Linux's @url{https://docs.kernel.org/fb/api.html, fbdev} interface.

@subsection i6300esb

@code{i6300esb} is a hardware watchdog featured in a lot of intel hardware, it
can be reset by using @code{write} and can be configured using
@code{ioctl} like:

@example
WDOG_START     = 1 // Start the count.
WDOG_STOP      = 2 // Stop the count.
WDOG_HEARTBEAT = 3 // Reset and set a new heartbeat period in seconds.

ioctl(wdog, WDOG_START, ignored); // Enable 2:1 scaling.
ioctl(wdog, WDOG_STOP,  ignored); // Enable 1:1 scaling.
ioctl(wdog, WDOG_HEARTBEAT, pointer_to_uint32_t);
@end example

There is no default heartbeat count, so be sure to configure it if you do not
want mayhem. Access to reset and configuration can be restricted by using
MAC.

While this piece of hardware allows for hooking up interrupts and reboot
separately when the timer expires, Ironclad right now will only reboot when
the timer expires.

@subsection pcspeaker

@code{pcspeaker} represents the IBM PC speaker, it is interfaced with using
@code{ioctl}, as such:

@example
ioctl(fd, ignored, pointer_to_uint32_t_frequency_in_hz);
@end example

@subsection ps2keyboard/ps2mouse

The devices @code{ps2keyboard} and @code{ps2mouse} exposes x86's native PS2
interfaces, @code{ps2keyboard} is a normal character device that returns
scancodes as they are received. @code{ps2mouse} is a character device that
returns mouse packets following the structure:

@example
struct mouse_data @{
   uint32_t x_variation;
   uint32_t y_variation;
   uint8_t  is_left_click;
   uint8_t  is_right_click;
@};
@end example

@code{ps2mouse} supports a series of @code{ioctl} calls for setting different
modes and talking directly with the PS2 controller:

@example
PS2MOUSE_2_1_SCALING     = 1
PS2MOUSE_1_1_SCALING     = 2
PS2MOUSE_SET_RES         = 3
PS2MOUSE_SET_SAMPLE_RATE = 4

ioctl(mouse, PS2MOUSE_2_1_SCALING, ignored);  // Enable 2:1 scaling.
ioctl(mouse, PS2MOUSE_1_1_SCALING, ignored);  // Enable 1:1 scaling.
ioctl(mouse, PS2MOUSE_SET_RES, resolution);   // (0 - 3).
ioctl(mouse, PS2MOUSE_SET_SAMPLE_RATE, rate); // (0 - 200).
@end example

Valid resolutions and sample rates are values for the PS2 controller, else
the call is ignored. For valid values and their meaning refer to
@uref{https://isdaman.com/alsos/hardware/mouse/ps2interface.htm, this website}.

@subsection sata

The devices starting by @code{sata} represent several SATA AHCI block devices.
For now only SATA drives are supported, support for ATAPI is not present.

These SATA drives have internal caching at the driver level, so they must be
@code{sync}'d for data integrity when wanting to ensure data coherency.

@subsection serial

The devices starting by @code{serial} represent the several character devices
used for each present serial port, they support read/write operations, but no
TTY interface is exposed, they are raw byte streams.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented as the serial devices are not ttys but
just byte streams.

The default baud for all ports is set to be @code{115200}.

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texi

@bye
