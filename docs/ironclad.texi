\input texinfo
@setfilename ironclad.info
@documentencoding UTF-8
@settitle Kernel interfaces

@copying
Copyright @copyright{} 2023 streaksu

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@title Ironclad kernel and userland interface
@subtitle Methods to interface with the kernel from boot-time and userland.
@author streaksu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents

@ifnottex
@node Top
@top Ironclad
@insertcopying
@end ifnottex

@menu
* General information::              General information about the project
* Boot-time command-line options::   Command-line options
* Embedded facilities and RTC::      Features and interfaces for embedded work
* Memory allocation algorithms::     The avaiable allocation algorithms.
* Syscalls::                         The main method of userland to interface
* Devices and their properties::     Devices exposed by the kernel
* GNU Free Documentation License::   Copying and sharing this manual

@detailmenu
--- The Detailed Node Listing ---

General information

* Audience::                The people for whom this manual is written.
* How to contribute::       How to contribute code to the kernel.
* Error reporting::         How to report issues with the kernel.
* Navigating the source::   Structure of the project.
* Formal verification::     Current state of the formal verification effort.

Boot-time command-line options

* Format::                 Description of the format.
* List::                   List of all the available cmdline arguments.

Embedded facilities and RTC

* Ticks and other interruptions::     Thread interruptions to expect.
* Scheduling and predictability::     Scheduling in Ironclad in depth.

Memory allocation algorithms

* standard::             The standard allocator.
* alloconly::            The low profile allocator that does not free.

Userland state and conditions

* Program loading and ld.so::  Format of the loaded programs.
* Memory layout::              Layout of the memory in userland.

Mandatory access control

* How to configure MAC::      How MAC is configured.

Syscalls

* x86_64::                  x86_64 syscall ABI and table.
* Errno::                   Error conditions and their values.
* exit::                    Exit the callee process.
* arch_prctl::              Interacting with architectural thread-local data.
* open::                    Opening file-system entities.
* close::                   Closing file descriptors.
* read/write::              Read and write from an already opened file.
* seek::                    Modify and fetch file offsets.
* mmap/munmap::             Memory mapping and requesting.
* getpid/getppid::          Get the PIDs of the caller.
* exec::                    Launching new programs.
* clone::                   Create new processes and threads.
* wait::                    Waiting for execution of a child to finish.
* uname::                   Fetch basic system information.
* sethostname::             Hostname setting.
* lstat::                   Fetch file information.
* getcwd/chdir::            Current working directory manipulation.
* ioctl::                   IO multiplexer.
* sched_yield::             Relinquish CPU time.
* set_deadlines::           Manage scheduler deadlines.
* pipe::                    Create pipes.
* dup/dup2::                Duplicate file descriptors.
* sysconf::                 Fetch general system parameters and information.
* access::                  Testing file permissions.
* thread_sched::            Manage scheduler-related thread permissions.
* fcntl::                   Multiplexed operations for files.
* exit_thread::             Exit the calling thread.
* getrandom::               Bypass /dev/random for avoiding DoS attacks.
* mprotect::                Change memory permissions.
* set_mac_capabilities::    Modify MAC capabilities.
* lock_mac::                Lock MAC down.
* add_mac_filter::          Configure MAC using filesystem-based filters.
* set_mac_enforcement::     Set enforcement to follow on MAC violations.
* mount::                   Mount partitions.
* umount::                  Unmount partitions.
* readlink::                Read the contents of a symlink.
* getdents::                Get directory entries.
* sync::                    Synchronize device caches.
* create::                  Create several kinds of files.
* delete::                  Delete files.

Devices and their properties

* Common devices::             Devices common to all architectures and targets.
* aarch64-stivale2 devices::   Devices specific to aarch64-stivale2.
* sparc-leon3 devices::        Devices specific to sparc-leon3.
* x86_64-multiboot2 devices::  Devices specific to x86_64-multiboot2.

@end detailmenu
@end menu

@node General information
@chapter General information

As the README of the project states, Ironclad is a kernel for x86_64 devices
exclusively (for now), written in Ada. The goal of the project is to create
a POSIX kernel for hobbyist fun, maybe one day for real life use. Ironclad has
a lot of features one would expect on a modern system, and the list only
continues to grow, like support for desktop environments, true multitasking, a
good memory manager, and a fully functional userland with dynamic linking and
ELF loading.

@node Audience
@section Audience

This manual is designed to document and give information about the several
interfaces and devices Ironclad exposes, so developers of userland applications
and other programmers can read inner details of how to interface with the
kernel without having to navigate the (often cryptic and scary Ada) code.

@node How to contribute
@section How to contribute

Thanks for considering contributing to Ironclad, it means a lot.

There are several ways one can help the Ironclad project, from writing and
correcting documentation to contributing source.

For submitting patches, be it for Ironclad's webpages, kernel code, or
documentation, please submit the patch to the project's
@url{https://savannah.nongnu.org/patch/?group=ironclad, patch manager},
(@url{https://savannah.nongnu.org/patch/?group=ironclad&func=additem, create an item}).

If prefered, one can send a patch in
@email{bug-ironclad@@nongnu.org, bug-ironclad}.

When contributing code, it's good to keep in mind these guidelines:

@enumerate
@item
One may only contribute code that complies with the project's license, or code
ruled by GPL-compatible licenses under certain conditions, its the
responsability of the contributor to ensure this is the case.

@item
Add license headers and detail the authors of the code. For files with a main
author and small touches being done on top of it, you can update the authors in
the copyright to `Copyright (C) 2022 [main author's name], et. al.`, or add
your name or pseudonym for a major contribution to the comma-separated list.

@item
It goes a long way to add the relevant documentation as comments and standalone
documentation when considered necessary. While not necessary, you save me the
trouble of having to add it later. :D
@end enumerate

@node Error reporting
@section Error reporting

Ironclad is a fairly new project at the end of the day, so things are prone to
fail. Once an issue arises, one can open a bug report at the
@url{https://savannah.nongnu.org/bugs/?group=ironclad, project's bug tracker},
(@url{https://savannah.nongnu.org/bugs/?group=ironclad&func=additem, create an item}).

@node Navigating the source
@section Navigating the source

The source of Ironclad can be found on its repository under the @code{source}
directory. It has several subdirectories with the following meanings:

@table @code
@item arch
Architecture-dependent code.

@item cryptography
Cryptographic facilities, cypher implementations, entropy management.

@item devices
Several device drivers, physical and virtual.

@item lib
Functions and libraries for utilities used in the rest of the kernel.

@item memory
Memory management, physical as well as virtual.

@item networking
Networking drivers and data.

@item userland
Userland code for loaders, processes, and such.

@item vfs
VFS structure and FS drivers.
@end table

Apart of those subdirectories, @code{source} contains the @code{main.adb} of
the kernel, @code{pragmas.adc} containing the pragmas used for the rest of the
kernel code, and some other files and drivers that do not fit in the former
subdirectories.

The code under @code{tests} does some general testing of facitilities that
can be tested outside a final Ironclad binary.

@node Formal verification
@section Formal verification

Right now the source of Ironclad is ongoing a process to raise its verification
status to @url{https://docs.adacore.com/spark2014-docs/html/ug/en/usage_scenarios.html#levels-of-spark-use, a mix of silver and gold level}.
This is done with the goal of ensure the absence of errors in a crucial system
component like the kernel, and for ensuring the suitability of Ironclad for
embedded and mission critical tasks.

@node Boot-time command-line options
@chapter Boot-time command-line options

Ironclad takes, as part of its boot protocol, a series of options and values.
The parsing of this options is architecture and platform independent, while the
ability to modify said options and values is entirely up to the platform and
bootloader.

@node Format
@section Format

The format is a list of keys that can have arguments or not in a C-style
NUL-terminted string, as such:

@example
key1=value1 key2 key3 ... keyN
@end example

@node List
@section List

This are the keys and values the kernel takes, and under which circumstances:

@table @code
@item root=<device>
Device to mount as root, if any.

@item init=<path>
Path to a program that will be booted by the kernel when finished loading.
The program will be started with @code{stdin} set to @code{/dev/null}, and
@code{stdout} and @code{stderr} set to @code{/dev/debug}.

@item syscalltracing
Enables tracing syscalls and their arguments, really performance taxing, but
essential for userland kernel debugging.
@end table

@node Embedded facilities and RTC
@chapter Embedded facilities and RTC

Ironclad supports several features geared towards embedded and real time work,
this section approaches what to expect and how to interact with the features.

@node Ticks and other interruptions
@section Ticks and other interruptions

Ironclad will not interrupt your running thread for timer or heartbeats, in
that way, ironclad is tickless.

However, Ironclad can interrupt a process for scheduling-related stops, this
is totally normal and can introduce substantial delays on systems with a lot
of processes, or introduce jitter on systems that desire absolutely 0 stops.

For how to get around scheduling-related ticks, read about @code{THREAD_MONO}
at @pxref{Scheduling and predictability}.

@node Scheduling and predictability
@section Scheduling and predictability

Scheduling in Ironclad is done using Rate-Monotonic Scheduling (RMS).

RMS is an optimal fixed-priority policy where the higher the frequency of a
task, the higher is its priority. This approach allows Ironclad to provide
scheduling guarantees for hard real time applications.

@subsection Predictability and guarantees

The sequence of scheduled tasks is fully predictable. Once priorities are
assigned using RMS, higher priority threads will interrupt lower priority
threads according to their periods, specified using @pxref{set_deadlines}.

Thanks to RMS, deadlines are mathematically guaranteed to be met as long as an
upper bound of CPU time utilization is not exceeded. Said bound can be
calculated using the number of tasks following the schedulability test:

@tex
$$ \sum_{i=1}^{n}{U_i}=\sum_{i=1}^{n}{C_i \over T_i}\leq n([2^{1/n}]-1) $$
@end tex

Where:

@table @math
@item U_i
CPU time utilization of a thread.
@item C_i
CPU time needed by the thread.
@item T_i
Period of the thread.
@item n
Number of threads to be scheduled.
@end table

When the number of threads tends to infinity, the condition tends to:

@tex
$$ \lim_{n\rightarrow\infty}n([2^{1/n}]-1)=\ln 2\approx 0.693147\ldots $$
@end tex

The kernel will just always compare with this approximated value for
simplicity and due to floating-point limitations. If this quick test is not
passed, the kernel will warn about it, but will not refuse to schedule, since
the user might know better, or may not want to respect deadlines at all.

Since the kernel leaves the responsability (and priviledge) of ensuring a
correct scheduling setup to the user, this opens the door to a number of tricks
to break through the 69% usage ceiling, while keeping deadlines alive and well.

@table @code
@item Harmonic chains and task periods
Thanks to the @url{https://ieeexplore.ieee.org/document/160369, work of Kuo and Mok},
we know that for harmonic sets of tasks, the schedulability test becomes:
@tex
$$ \sum_{i=1}^{n}{U_i}=\sum_{i=1}^{n}{C_i \over T_i}\leq K([2^{1/K}]-1) $$
@end tex

Where @math{K} is the number of harmonic sets, for @math{1}, the utilization
becomes 100%.

A harmonic set of tasks is the set where every task evenly divides the period
of every longer period. For example, a harmonic set of 3 tasks periods is
@code{@{20, 60, 120@}}
@end table

@subsection Monothreading

Scheduling in Ironclad supports creating critical sections backed by the kernel
using @pxref{thread_sched} and @code{THREAD_MONO}.

This flag will make the scheduler not preemt at all from the thread until
rqeuested, by using @xref{sched_yield} or relinquishing execution in any other
similar way. Doing that will not reset the flag, but it will allow the system
to search for another possibly preemtible thread.

Note that this flag only applies to the core to request the scheduling, other
cores in the system will continue to preempt as usual.

@node Memory allocation algorithms
@chapter Memory allocation algorithms

Ironclad features several memory allocator choices for use by the userland
and kernel.

@node standard
@section standard

The standard allocator is a bitmap-based, simple allocator with 4K-sized
blocks.

The allocator allows freeing, it suffers from heavy fragmentation when
frequenty using big allocations, and takes a relative lot of memory to keep
track of status.

@node alloconly
@section alloconly

The 'alloconly' allocator is an alternative, bump-based allocator that is
much faster and uses way less memory than the standard allocator, while not
being able to free as its biggest trade-off.

This allocator is appropiate for embedded applications that are recommended
to allocate all the program will ever need at the beggining of its execution,
and thats it.

@node Userland state and conditions
@chapter Userland state and conditions

Ironclad places several requirements on loaded userland programs, from the
format of which, to memory layout.

@node Program loading and ld.so
@section Program loading and ld.so

Loaded programs must be under the ELF64 format, other formats may be supported
in the future. Loaded programs can be relocatable or not.

@code{ld.so} is a special case, it's loaded from the information on the headers
of the primary loaded program, and is assumed to be relocatable (static-PIE).

@node Memory layout
@section Memory layout

Loaded programs are loaded at address 0, and they are free to allocate
themselves at nearby offsets.

@code{ld.so} and entities like stacks, anonymous memory regions, and others,
will be randomized on load time following
@uref{https://en.wikipedia.org/wiki/Address_space_layout_randomization, ASLR},
and must not be relied upon. It is up to @code{ld.so} to optionally place
additionally loaded libraries at random offsets.

@node Mandatory access control
@chapter Mandatory access control

Mandatory access control (MAC) forms one of the main components of Ironclad
security.

With several restrictive settings that are inherited from parent processes to
children, we can ensure processes will only have access to the minimum
required set of permissions for their task.

MAC does not necesarily help with preventing breaches of security, but
minimizes the things a breached process can do, when configured correctly.

@node How to configure MAC
@section How to configure MAC

A series of coarse permissions, called capabilities, that restrict the process
on what it can and cannot do, can be done by using @ref{set_mac_capabilities}.

Apart of capabilities, access to filesystem structures and permission
management can be done using @ref{add_mac_filter}.

The method of acting on MAC violations and failures can be set by using
@ref{set_mac_enforcement}. Possible values include denying requests, killing
the offending part outright, or denying and additionally logging the event.

Locking can be done with @ref{lock_mac}. Once locked, MAC setup is done, and
it comes into effect. When locked, processes can only restrict themselves
further, but not make them more permissive. Locking is not reversible.

MAC is meant to be configured and locked in a parent process like init in a
classic UNIX-like boot. There, the init can configure the desired processes
to be launched under the necessary permissions.

The permissions of the parent process booted by the kernel as passed in
the @code{init} cmdline option are all denied.

For example:

@example
int main(void) @{
    // Set our permissions and spawn a child, the child will inherit them.

    // We create a process that can access to allocation but not deallocation,
    // grant access to entropy, and change its own scheduling.
    if (set_mac_capabilities(MAC_CAN_ALLOC_MEM | MAC_CAN_ACC_ENTROPY |
                             MAC_CAN_CHANGE_SCHED) != 0) @{
        return -1;
    @}
    if (spawn("/usr/bin/example1", NULL, NULL) != 0) @{
        return -1;
    @}

    // Lock, and we are done!
    if (lock_mac() != 0) @{
        return -1;
    @}
@}
@end example

@node Syscalls
@chapter Syscalls

Syscalls in Ironclad have an architecture-dependent ABI, here is a list of the
supported architectures and the ABI for each of them.

@node x86_64
@section x86_64

Syscalls are invoked in Ironclad by triggering an interrupt to vector
@code{0x80}.

The index of the syscall is passed on @code{%rax}, while the return value is
returned on @code{%rax}, errno is returned on @code{%rdx}, arguments are passed
over @code{%rdi}, @code{%rsi}, @code{%rdx}, @code{%rcx}, @code{%r8},
@code{%r9}, and @code{%r10}, following the SysV ABI.

The list of syscalls ordered by their index in @code{rax} for the platform is:

@enumerate 0
@item
@xref{exit}.
@item
@xref{arch_prctl}.
@item
@xref{open, open}.
@item
@xref{close, close}.
@item
@xref{read/write, read}.
@item
@xref{read/write, write}.
@item
@xref{seek}.
@item
@xref{mmap/munmap, mmap}.
@item
@xref{mmap/munmap, munmap}.
@item
@xref{getpid/getppid, getpid}.
@item
@xref{getpid/getppid, getppid}.
@item
@xref{exec}.
@item
@xref{clone}.
@item
@xref{wait}.
@item
@xref{uname}.
@item
@xref{sethostname}.
@item
@xref{delete}
@item
@pxref{lstat, lstat}.
@item
@xref{getcwd/chdir, getcwd}.
@item
@xref{getcwd/chdir, chdir}.
@item
@xref{ioctl}.
@item
@xref{sched_yield}.
@item
@xref{set_deadlines, set_deadlines}.
@item
@xref{pipe, pipe}.
@item
@xref{dup/dup2, dup}.
@item
@xref{dup/dup2, dup2}.
@item
@xref{sysconf, sysconf}.
@item
@xref{access}.
@item
@xref{thread_sched, get_thread_sched}.
@item
@xref{thread_sched, set_thread_sched}.
@item
@xref{fcntl}.
@item
@xref{exit_thread}.
@item
@xref{getrandom}.
@item
@xref{mprotect}.
@item
@xref{sync}
@item
@xref{set_mac_capabilities}.
@item
@xref{lock_mac}.
@item
@xref{add_mac_filter}.
@item
@xref{set_mac_enforcement}
@item
@xref{mount, mount}.
@item
@xref{umount, umount}.
@item
@xref{readlink}.
@item
@xref{getdents}.
@item
@xref{create}
@end enumerate

@node Errno
@section Errno

Errno are values returned by the kernel to detail the nature of an error in
depth. When a syscall does not error out, it returns the value 0 on the errno
field. Here is a table of all the possible errno and its values and meaning:

@table @code
@item ERANGE (3)
The passed value was not big enough.

@item EACCES (1002)
The passed access for a variable points to bad memory.

@item EAGAIN (1006)
The requested resource is not available at the moment.

@item EBUSY (1010)
The requested resource is busy and cannot handle the request.

@item ECHILD (1012)
The passed value is not a child process.

@item EFAULT (1020)
The passed value would make the program fault.

@item EINVAL (1026)
The passed value is not valid for the called syscall.

@item EIO (1027)
The requested operation failed at a device level.

@item EMFILE (1031)
Too many files were opened by the process.

@item ENAMETOOLONG (1036)
The passed value is too big for the syscall.

@item ENOENT (1043)
No such file or directory.

@item ENOSYS (1051)
The requested syscall or flag is not implemented.

@item ESPIPE (1069)
A seek was issued to an invalid device.

@item ESRCH (1070)
The passed item could not be found after a search.

@item ESPIPE (1081)
The passed FD is in a bad state.
@end table

@node exit
@section exit

@example
void exit(uint64_t status);
@end example

This syscall terminates the calling process "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this, rookie mistake.
@end itemize

@node arch_prctl
@section arch_prctl

@example
int arch_prctl(int code, uint64_t argument);
@end example

This syscall interacts with architecture-specific thread-local storage. For
x86_64, these are the available codes:

@table @code
@item ARCH_SET_FS (1)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_FS (2)
Stores the current thread's FS into the variable pointed to by @code{argument}.

@item ARCH_SET_GS (3)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_GS (4)
Stores the current thread's GS into the variable pointed to by @code{argument}.
@end table

This syscall returns @code{0} on success, and @code{-1} on failure.
errno is to be set to the following values on failure:

@itemize @bullet
@item
@code{EINVAL}: @code{code} is not valid.

@item
@code{EFAULT}: @code{argument} is outside the available address space.
@end itemize

@node open
@section open

@example
int open(int dir_fd, char *path, int path_len, int flags);
@end example

@code{open} opens the passed file relative to @code{dir_fd}, depending on the
flags passed. It does not create the file if not existent. By default, the file
descriptor will remain open accross an @code{exec}.

@code{flags} can be an OR'd field of the following elements:

@table @code
@item O_RDONLY (0b000001)
Makes the file able to be read.

@item O_WRONLY (0b000010)
Makes the file able to be written to.

@item O_APPEND (0b000100)
Makes the file be opened at the end of the file, instead of the beggining.

@item O_CLOEXEC (0b001000)
Will make the file close when @code{exec}'d.

@item O_NOFOLLOW (0b0100000000)
Do not follow symlinks when opening the file.

@item O_NONBLOCK (0b1000000000)
Make the file not block on read or write operations when possible.
@end table

The syscall returns the opened file descriptor or @code{-1} on error, and errno
is set to the following:

@itemize @bullet
@item
@code{ENOENT}: The referenced file does not exist.

@item
@code{EINVAL}: Combination of @code{flags} is not valid.

@item
@code{EMFILE}: Too many files are already owned by the process.

@item
@code{EFAULT}: The passed path is outside the available address space.
@end itemize

@node close
@section close

@example
int close(int fd);
@end example

@code{close} closes an open file descriptor. Once no open references exist of a
file descriptor, its resources are freed, and the file deleted if needed.

The syscall returns 0 on success and -1 in failure, and errno is set to:

@itemize @bullet
@item
@code{EBADF}: The passed file to @code{close} is not valid.
@end itemize

@node read/write
@section read/write

@example
ssize_t read(int fd, void *buffer, size_t count);
ssize_t write(int fd, void *buffer, size_t count);
@end example

These syscalls attempts to read or write up to passed count from the passed file descriptor.

On files that support seeking, the operation commences at the file offset, and
the file offset is incremented by the number of bytes read or written. If the
file offset is at or past the end of file, no bytes are read or written, and
the operation returns zero.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed fd is not suitable for the operation.

@item
@code{EIO}: The requested operation failed at the device level.
@end itemize

@node seek
@section seek

@example
off_t seek(int fd, off_t offset, int whence);
@end example

This syscall repositions the file offset of the passed file description to the
passed offset according to the directive whence as follows:

@itemize @bullet
@item
@code{SEEK_SET} (1): Set to the passed offset.

@code{SEEK_CUR} (2): Set to the current offset plus the passed offset.

@code{SEEK_END} (4): Set to the size of the file plus the passed offset.
@end itemize

This syscall returns the resulting offset, or @code{-1} on failure. errno is to
be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EINVAL}: The whence is malformed or the resulting offset would be invalid.

@item
@code{ESPIPE}: @code{seek} was called on a TTY or a pipe.
@end itemize

@node mmap/munmap
@section mmap/munmap

@example
void *mmap(void *hint, size_t length, int protection, int flags, int fd, off_t offset);
int munmap(void *address, size_t length);
@end example

@code{mmap} creates a new mapping in the virtual address space of the calling
process. An address can be passed, if it is @code{null}, then the kernel gets
to choose the address, else, it is taken as a hint about where to place the
mapping.

@code{hint} and @code{length} are required to be aligned to page boundaries
for the running architecture, else it will fail.

@code{protection} and @code{flags} are a bitfield of the following flags:

@itemize @bullet
@item
@code{PROT_NONE} (0b0000): No specific protection.

@item
@code{PROT_READ} (0b0001): Read permissions.

@item
@code{PROT_WRITE} (0b0010): Write permissions.

@item
@code{MAP_FIXED} (0b0100): Use hint as a hard requirement.

@item
@code{MAP_ANON} (0b1000): Mapping is not backed by any file.
@end itemize

@code{munmap} will unmap a range for the virtual address space of the calling
process, this values must be the same as passed and returned by @code{mmap},
partial unmapping is not allowed.

@code{mmap} returns a pointer to the allocated area, or @code{-1} on failure.
@code{munmap} returns @code{0} on success, @code{-1} on failure. Both functions
set the following errno:

@itemize @bullet
@item
@code{EINVAL}: Bad hints or parameters.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getpid/getppid
@section getpid/getppid

@example
int getpid();
int getppid();
@end example

@code{getpid} returns the process ID (PID) of the calling process.
@code{getppid} does the same but it returns the one of the parent, which is the
process that created the callee by a myriad of ways.

This functions are always successful.

@node exec
@section exec

@example
int exec(const char *path, int path_len, char *const argv[], int argv_len, char *const envp[], envp_len);
@end example

This syscall executes the program passed with the passed argv and evp, closing
all the threads of the callee process and putting a single one in place for
the new program. Other process-specific elements like file descriptors are
untouched.

This syscall only returns in failure with @code{-1} with the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file passed in path doesnt exist.

@item
@code{EACCES}: The file couldn't be launched out of a permission error.
@end itemize

@node clone
@section clone

@example
#define CLONE_PARENT 0b01
#define CLONE_THREAD 0b10

pid_t clone(void *callback, uint64_t arg, void *stack, int flags, void *tls);
@end example

This syscall creates a new thread or process depending on @code{flags}.
@code{flags} can be an OR'd combination of the following flags:

@itemize @bullet
@item
@code{CLONE_PARENT} (0b01): The process or thread will be a child of the parent
of the caller process, instead of the caller process itself.

@code{CLONE_THREAD} (0b10): If set, a thread will be created and added to the
parent process, if not set, a process will be created instead. The child
process will only have the callee thread cloned. The other threads, if any,
are not cloned.
@end itemize

This syscall returns @code{0} on success for the child, and the children PID or
TID to the parent, in failure, the parent gets @code{-1} with the following
errno:

@itemize @bullet
@item
@code{EAGAIN}: The system could not create the entity right now, try again
later.

@item
@code{EINVAL}: @code{CLONE_PARENT} is specified and the caller process has no
parent.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node wait
@section wait

@example
pid_t wait(pid_t pid, int *status, int options);
@end example

This syscall suspends execution until the passed pid exits, to then store the
exit code in @code{status}.

@code{wait} allows the option @code{WNOHANG(0b000010)} for non-blocking
waiting, if the process has not finished yet, @code{0} will be returned.

@code{pid} can be a PID the callee is a parent of, or @code{-1} to wait on all
the PIDs the callee has as children. @code{0}, which waits on all the children
of a process group, is not implemented yet.

This syscall returns the PID waited on or @code{-1} on failure, along with the
following errno:

@itemize @bullet
@item
@code{ECHILD}: The passed PID does not exist.

@item
@code{EINVAL}: The passed options are not correct or the passed PID is @code{0}
@end itemize

@node uname
@section uname

@example
struct utsname @{
    char sysname[65];  // Kernel name (e.g., "Ironclad")
    char nodename[65]; // Hostname of the machine.
    char release[65];  // Kernel release (e.g., "2.6.28")
    char version[65];  // Kernel configuration date for debug purposes.
    char machine[65];  // Hardware identifier (e.g., "x86")
@};

int uname(struct utsname *name);
@end example

This syscall reports kernel information, like version, name, and hostname.
It returns @code{0} on success, and @code{-1} on failure, with the only errno
being @code{EFAULT} if the passed pointer is in an invalid address.

@node sethostname
@section sethostname

@example
int sethostname(const char *buffer, size_t length);
@end example

This syscall sets the kernel hostname to the passed string. @code{0} is
returned on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed buffer points to an invalid address.

@item
@code{EINVAL}: The passed length is bigger than the kernel can handle or 0.

@item
@code{EACCES}: MAC did not allow this.
@end itemize

@node lstat
@section lstat

@example
struct stat @{
    dev_t st_dev;
    ino_t st_ino;
    mode_t st_mode;
    nlink_t st_nlink;
    uid_t st_uid;
    gid_t st_gid;
    dev_t st_rdev;
    off_t st_size;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    blksize_t st_blksize;
    blkcnt_t st_blocks;
@};

int lstat(int dir_fd, const char *path, int path_len, struct stat *statbuf);
@end example

This syscalls return information about a file. No permissions are required
for fetching the file information, but they are required for the containing
directories.

@code{0} is returned on success, @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The passed path or file descriptor is not valid.

@item
@code{ENOENT}: The file pointed by @code{path} does not exist.

@item
@code{EFAULT}: The passed address for the path or stat buffer is not valid.
@end itemize

@node getcwd/chdir
@section getcwd/chdir

@example
char *getcwd(char *buf, size_t size);
int chdir(const char *path, int path_len);
@end example

This syscalls manage the current working directory of the callee process.
@code{getcwd} will fetch it as an absolute path, while chdir will set it with
a C-style string.

@code{getcwd} returns a pointer to the string passed, or @code{NULL} if the
string is not big enough, including @code{NUL}, and sets the following errno:

@itemize @bullet
@item
@code{EINVAL}: The passed length is 0.

@item
@code{ERANGE}: The passed buffer + size is not big enough for the path, and it
is safe to reallocate and try again.

@item
@code{EFAULT}: The passed buffer has a bad address.
@end itemize

@code{chdir} returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed path points to a bad address.

@item
@code{ENAMETOOLONG}: The passed path is too long.

@item
@code{ENOTDIR}: The passed path is not a directory or has 0 length.
@end itemize

@node ioctl
@section ioctl

@example
int ioctl(int fd, unsigned long request, void *argument);
@end example

This syscall manipulates the underlying device parameters of special files. It
allows a device-dependent API for fetching and setting several modes.

@code{ioctl} returns @code{0} on success and @code{-1} on failure, and sets the
following errno:

@itemize @bullet
@item
@code{ENOTTY}: The passed file does not support the passed ioctl.

@item
@code{EBADF}: The passed file does not exist for the process.

@item
@code{EFAULT}: The passed argument is in non-accesible memory
@end itemize

@node sched_yield
@section sched_yield

@example
int sched_yield(void);
@end example

This syscall relinquishes execution of the caller thread.
Its up for the kernel how far in the queue of execution this thread will go.

This syscall returns @code{0} always, as it never fails, this is done for
compatibility with POSIX instead of having a @code{void} return type.

@node set_deadlines
@section set_deadlines

@example
int set_deadlines(int run_time, int period);
@end example

This syscalls sets the run time and period of the calling thread, the meaning
of this is explained in @xref{Scheduling and predictability}.

The units of both runtime and period are microseconds.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow the operation.
@item
@code{EINVAL}: Bad period or runtime make system not schedulable, or are
nonsensical.
@end itemize

@node pipe
@section pipe

@example
int pipe(int pipefd[2], int flags);
@end example

This syscalls creates a pipe with the passed flags and returns the registered
file descriptors in @code{pipefd}. Index @code{0} is the reader end, @code{1}
is the writing one.

The only available flag for use is @code{O_NONBLOCK}.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{pipefd} points to bogus memory.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node dup/dup2
@section dup/dup2

@example
int dup(int oldfd);
int dup2(int oldfd, int newfd);
@end example

This syscalls allocate new file descriptors pointing to the same file as the
passed file descriptor. @code{dup} chooses a descriptor itself, while
@code{dup2} will replace @code{newfd} with the new descriptor,
closing the old one if necessary.

The flags of the duplicated file descriptor are reset, this means
@code{O_CLOEXEC}, and other flags like @code{O_NONBLOCK} are not inherited.

These 2 syscalls return the new fd on success and @code{-1} on failure.
The errno codes set on failure are:

@itemize @bullet
@item
@code{EBADF}: The passed file descriptor is not owned by the process.

@item
@code{EMFILE}: Too many files have already been opened by the process.
@end itemize

@node sysconf
@section sysconf

@example
#define SC_PAGESIZE      1 // Page size of the system.
#define SC_OPEN_MAX      2 // Maximum amount of files per process.
#define SC_HOST_NAME_MAX 3 // Maximum length of hostnames.
#define SC_AVPHYS_PAGES  4 // Number of physical pages available for use.
#define SC_PHYS_PAGES    5 // Number of total physical pages the system has.
#define SC_NPROC_ONLN    6 // Number of processors active and used by the OS.
long int sysconf(int request);
@end example

This syscalls fetches the requested information, and returns it.

The syscall return the requested information on success and @code{-1} on
failure. The errno codes set on failure are:

@itemize @bullet
@item
@code{EINVAL}: Invalid request.
@end itemize

@node access
@section access

@example
int access(const char *path, int path_len, int mode);
@end example

This syscalls tests for file permissions and access without opening it.
@code{path} will be checked for a set of options or'd in @code{mode}, the
options are:

@itemize @bullet
@item
@code{F_OK (0b0001)}: The existance of the file is checked.

@item
@code{R_OK (0b0010)}: Being able to read the file is checked.

@item
@code{W_OK (0b0100)}: Being able to write to the file is checked.

@item
@code{X_OK (0b1000)}: The file being executable is checked.
@end itemize

The syscall returns @code{0} on success of checking the passed conditions
and @code{-1} on failure. The errno codes set on failure are:

@itemize @bullet
@item
@code{EFAULT}: The passed path points to invalid memory.

@item
@code{EINVAL}: The passed @code{mode} is not valid.

@item
@code{ENOENT}: The requested path to check does not exist.
@end itemize

@node thread_sched
@section thread_sched

@example
int get_thread_sched(void);
int set_thread_sched(int flags);
@end example

This syscalls manage scheduling properties of the callee thread. Both functions
operate on a bitmap with the following bits

@itemize @bullet
@item
@code{THREAD_MONO (0b1)}: Marks whether the thread is a monothread, see
@xref{Scheduling and predictability} for details.
@end itemize

@code{get_thread_sched} returns the flags and does not fail, @code{set_thread_sched}
returns @code{0} on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow the operation.
@end itemize

@node fcntl
@section fcntl

@example
int fcntl(int fd, int cmd, int arg);
@end example

This syscall is a multiplexed syscall that performs the operations described
below on the open file descriptor @code{fd}. The operation is determined by
@code{cmd} and may take an optional argument @code{arg}.

The syscall's return value will depend on the requested @code{cmd}, and is
detailed along the operations below.

The valid operations are:

@itemize @bullet
@item
@code{F_DUPFD (1)}: Makes fcntl behave in a manner equivalent to @code{dup}.

@item
@code{F_GETFD (3)}: The flags used for @code{fd} will be returned, right now
only @code{FD_CLOEXEC} is supported. The syscall will return the flags on
success.

@item
@code{F_SETFD (4)}: The flags for @code{fd} will be set with @code{arg}. The
syscall will return @code{0} on sucess.
@end itemize

On failure, the syscall returns @code{-1}. The returned @code{errno} are:

@itemize @bullet
@item
@code{EINVAL}: The passed @code{cmd} is not implemented by the kernel.

@item
@code{EBADF}: The passed @code{fd} is not open.
@end itemize

@node exit_thread
@section exit_thread

@example
void exit_thread(void);
@end example

This syscall terminates the calling thread "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getrandom
@section getrandom

@example
ssize_t getrandom(void *buffer, size_t length);
@end example

This syscall fills the buffer pointed to @code{buffer} with up to @code{length}
random bytes. These bytes can be used for cryptographic purposes.

The operation is the same as reading from @code{/dev/random}. It is provided
instead of just reading from the device as to avoid denial of service attacks
based on exhausting the file descriptor limit of the system, along with other
vulnerabilities and inconveniences related to the classic file interface.

The syscall returns the count of read random data or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{buffer} points to invalid memory.
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node mprotect
@section mprotect

@example
int mprotect(void *addr, size_t len, int prot);
@end example

This syscall allows to change the permission of a range of memory of the passed
length pointed by @code{addr}, previously mapped by the caller. The format of
@code{prot} is the same as @code{mmap}.

@code{addr} and @code{len} must be aligned to an architecture-valid alignment.

The syscall returns the @code{0} on success or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{addr} points to invalid memory.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node set_mac_capabilities
@section set_mac_capabilities

@example
#define MAC_EXIT_ITSELF   0b0000001
#define MAC_CREATE_OTHERS 0b0000010
#define MAC_CHANGE_SCHED  0b0000100
#define MAC_ACC_ENTROPY   0b0001000
#define MAC_ALLOC_MEM     0b0010000
#define MAC_DEALLOC_MEM   0b0100000
#define MAC_MANAGE_MNT    0b1000000

int set_mac_capabilities(unsigned long request);
@end example

This syscall sets MAC filters on the way described in
@ref{Mandatory access control}.

This syscall always returns @code{0} and does not fail, settings will just
be ignored if permission to change them is not granted.

@node lock_mac
@section lock_mac

@example
int lock_mac(void);
@end example

This syscall locks MAC modification as described in
@ref{Mandatory access control}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC was already locked.
@end itemize

@node add_mac_filter
@section add_mac_filter

@example
#define MAC_FILTER_INC_FILES 0b0000001
#define MAC_FILTER_INC_DIRS  0b0000010
#define MAC_FILTER_R         0b0000100
#define MAC_FILTER_W         0b0001000
#define MAC_FILTER_EXEC      0b0010000

struct mac_filter @{
    char     path[75];
    int      length;
    uint32_t perms;
@};

int add_mac_filter(struct mac_filter *filter);
@end example

This syscall adds file-based filters as described in
@ref{Mandatory access control}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed pointer does not point to valid memory.
@item
@code{EAGAIN}: The system has reached a limit on registered rules.
@item
@code{EINVAL}: The passed rule is already covered or conflicts with an existent
one.
@end itemize

@node set_mac_enforcement
@section set_mac_enforcement

@example
#define MAC_DENY            0b001
#define MAC_DENY_AND_SCREAM 0b010
#define MAC_KILL            0b100

int set_mac_enforcement(unsigned long request);
@end example

This syscall sets the action to take for enforcement on MAC issues as explained
in @ref{Mandatory access control}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC was locked.
@end itemize

@node mount
@section mount

@example
int mount(const char *source, int source_len, const char *target,
   int target_len, const char *filesystemtype, unsigned long mountflags);
@end example

These syscalls mount and unmount FSs. @code{source} is the source device while
@code{target} is where to mount. The list of available filesystems for
@code{filesystemtype} is the following.

@itemize @bullet
@item
@code{ustar}: USTAR Read-only filesystem.
@item
@code{ext}: EXT family filesystem.
@end itemize

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: Wrong arguments.
@end itemize

@node umount
@section umount

@example
#define MNT_FORCE 1

int umount(const char *target, int target_len, int flags);
@end example

This syscalls unmount FSs. @code{target} is the path to unmount, while
@code{flags} allows the following options:
@itemize @bullet
@item
@code{MNT_FORCE}: Unmount the filesystem even if busy, can cause data loss.
@end itemize

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EBUSY}: The mount is busy, and @code{MNT_FORCE} was not passed.
@end itemize

@node readlink
@section readlink

@example
ssize_t readlink(char *path, int path_len, char *buffer, size_t buffer_len);
@end example

The syscall reads the redirected path of a symlink.

The syscalls return the read length on success or @code{-1} on failure, with
the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: The passed file is not a symbolic link.
@end itemize

@node getdents
@section getdents

@example
#define DT_UNKNOWN 0
#define DT_FIFO    1
#define DT_CHR     2
#define DT_DIR     4
#define DT_BLK     6
#define DT_REG     8
#define DT_LNK    10
#define DT_SOCK   12
#define DT_WHT    14

struct dirent @{
   uint64_t d_ino;
   uint64_t d_off;
   uint16_t d_reclen;
   uint8_t  d_type;     // One of the DT_ values.
   char     d_name[61]; // Null-terminated.
@};

ssize_t getdents(int fd, struct dirent *buffer, size_t size);
@end example

The syscall reads the contents of a directory all in one go, partial reads
are not supported.

The syscalls return the read length in bytes on success, or @code{0} if no
contents or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the arguments.
@item
@code{EBADFD}: @code{fd} does not contain a valid file.
@item
@code{ENOENT}: @code{fd} is not a directory.
@item
@code{EINVAL}: @code{size} is not big enough to fit all the directory entries.
@end itemize

@node sync
@section sync

@example
int sync(void);
@end example

The syscall flushes the associated caches of all external devices, which may
be needed in order to ensure data coherency on shutdown or other situations.

The syscall returns @code{0} or @code{-1} on failure, with a corresponding
errno. This is done as to be forward compatible with future modifications, the
syscall right now is not able to fail.

@node create
@section create

@example
int create(const char *path, int path_len, int file_type, int mode,
   size_t extra);
@end example

The syscall creates non existent files. @code{file_type} denotes the kind of
file, while @code{extra} may be used for the creation of some files, like
symlinks. It does not open the created file.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EINVAL}: The value of @code{file_type} or @code{mode} is not allowed.
@end itemize

@node delete
@section delete

@example
int delete(const char *path, int path_len);
@end example

The syscall deletes the file pointed to by @code{path}. If @code{path} points
to a directory, it must be empty.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{ENOENT}: @code{delete} points to a file not valid for deletion, if at all.
@end itemize

@node Devices and their properties
@chapter Devices and their properties

Ironclad exposes a number of devices, physical and virtual, to userland. All
of them are exposed under the @code{/dev} location, and support a series of
standard operations, like being manipulated by the usual file-related
syscalls like @code{read} or @code{write}, while sporting device-specific
interfaces in the form of device-specific @code{ioctl} requests.

The devices detailed in this chapter are divided in "Common devices", which
are devices featured regardless of the architecture running Ironclad, and
architecture-specific devices.

@node Common devices
@section Common devices

@subsection debug

@code{/dev/debug} wraps architecture-specific debug output channels for use
with file operations. For x86-based targets, this is QEMU's E9, for arm-based
and sparc-based targets, this is UART.

@subsection ramdev

The devices starting by @code{ramdev} are virtual devices representing the
RAM driver passed by some boot protocols, an FS can be mounted to them, usually
USTAR. These RAM devices are exclusively read-only.

@subsection random

The device @code{random} is equivalent to the one featured in other unix-like
kernels. Keep in mind that Ironclad has limited sources of entropy, so the
quality of this random numbers is a bit limited. Writing to the source is not
allowed, unlike other systems.

@code{/dev/urandom} does the same as @code{/dev/random}, and is only provided
for compatibility.

@code{getrandom} is provided as well for avoiding the file interface.

@subsection null/zero

@code{null} and @code{zero} are the equivalent of the @code{null} and
@code{zero} devices for platforms like Linux.

@code{null} returns @code{EOF} whenever read, and all the write operations are
discarded.

@code{zero} returns exclusively a stream of zeros when read, and all write
operations are discarded.

@subsection rtc

@code{/dev/rtc} exposes the hardware RTC in an architecture independent manner.

The device only allows the following @code{ioctl} operations.

The time structures handled represent ready-to-use, calendar timestamps.

@example
RTC_RD_TIME  = 1 // Reads time to the passed structure.
RTC_SET_TIME = 2 // Sets the RTC to the passed time.
struct rtc_time @{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;     /* unused */
    int tm_yday;     /* unused */
    int tm_isdst;    /* unused */
@};

ioctl(rtc, ..., pointer_to_rtc_time)
@end example

@subsection ptmx

If the kernel is configured to support PTYs, this device fulfills a similar
role to Linux's @code{/dev/ptmx}.

A major difference is that instead of @code{open} being used for creating
PTYs, @code{ioctl}, like the following:

@example
ioctl(ptmx_fd, 0, &result_master_fd);
@end example

Slaves are opened from the master FD in the same manner, this is done is said
way thanks to Ironclad's @code{/dev} system limitations.

@node aarch64-stivale2 devices
@section aarch64-stivale2 devices

@subsection pl011

The device @code{pl011} supports read operations for PL011 UART compatible
devices.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented, only the ones related to input stream
settings.

The default baud for the device is set to be @code{115200}.

@node sparc-leon3 devices
@section sparc-leon3 devices

This target has no special devices.

@node x86_64-multiboot2 devices
@section x86_64-multiboot2 devices

@subsection fb0

The @code{fb0} device exposes the framebuffer passed as part of the boot
protocol, when present. The device uses Linux's @url{https://docs.kernel.org/fb/api.html, fbdev} interface.

@subsection ps2keyboard/ps2mouse

The devices @code{ps2keyboard} and @code{ps2mouse} exposes x86's native PS2
interfaces, @code{ps2keyboard} is a normal character device, while
@code{ps2mouse} is a character device that returns mouse packets under the
structure:

@example
struct mouse_data @{
   uint32_t x_variation;
   uint32_t y_variation;
   uint8_t  is_left_click;
   uint8_t  is_right_click;
@};
@end example

@code{ps2mouse} supports a series of @code{ioctl} calls for setting different
modes and talking directly with the PS2 controller:

@example
PS2MOUSE_2_1_SCALING     = 1
PS2MOUSE_1_1_SCALING     = 2
PS2MOUSE_SET_RES         = 3
PS2MOUSE_SET_SAMPLE_RATE = 4

ioctl(mouse, PS2MOUSE_2_1_SCALING, ignored);  // Enable 2:1 scaling.
ioctl(mouse, PS2MOUSE_1_1_SCALING, ignored);  // Enable 1:1 scaling.
ioctl(mouse, PS2MOUSE_SET_RES, resolution);   // Set resolution (0 - 3).
ioctl(mouse, PS2MOUSE_SET_SAMPLE_RATE, rate); // Set sample rate (0 - 200).
@end example

Valid resolutions and sample rates are values for the PS2 controller, else
the call is ignored. For valid values and their meaning refer to
@uref{https://isdaman.com/alsos/hardware/mouse/ps2interface.htm, this website}.

@subsection serial

The devices starting by @code{serial} represent the several character devices
used for each present serial port, they support read/write operations, but no
TTY interface is exposed, they are raw byte streams.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented as the serial devices are not ttys but
just byte streams.

The default baud for all ports is set to be @code{115200}.

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texi

@bye
