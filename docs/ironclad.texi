\input texinfo
@setfilename ironclad.info
@documentencoding UTF-8
@settitle Kernel interfaces

@copying
Copyright @copyright{} 2022 streaksu

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@title Ironclad kernel and userland interface
@subtitle Methods to interface with the kernel from boot-time and userland.
@author streaksu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents

@ifnottex
@node Top
@top Ironclad
@insertcopying
@end ifnottex

@menu
* General information::              General information about the project
* Boot-time command-line options::   Command-line options
* Embedded facilities and RTC::      Features and interfaces for embedded work
* Memory allocation algorithms::     The avaiable allocation algorithms.
* Syscalls::                         The main method of userland to interface
* Devices and their properties::     Devices exposed by the kernel
* GNU Free Documentation License::   Copying and sharing this manual

@detailmenu
--- The Detailed Node Listing ---

General information

* Audience::                The people for whom this manual is written.
* How to contribute::       How to contribute code to the kernel.
* Error reporting::         How to report issues with the kernel.
* Navigating the source::   Structure of the project.
* Formal verification::     Current state of the formal verification effort.

Boot-time command-line options

* Format::                 Description of the format.
* List::                   List of all the available cmdline arguments.

Embedded facilities and RTC

* Ticks and other interruptions::         Thread interruptions to expect.
* Scheduling priority intervals::         Scheduling time slices.
* Real time and monothreaded scheduling:: RT and monothreads.
* Entering a real-time state::            Example for making RT-friendly state.

Memory allocation algorithms

* standard::             The standard allocator.
* alloconly::            The low profile allocator that does not free.

Userland state and conditions

* Program loading and ld.so::  Format of the loaded programs.
* Memory layout::              Layout of the memory in userland.

Syscalls

* x86_64::                  x86_64 syscall ABI and table.
* Errno::                   Error conditions and their values.
* exit::                    Exit the callee process.
* arch_prctl::              Interacting with architectural thread-local data.
* open/close::              Opening and closing a file.
* read/write::              Read and write from an already opened file.
* seek::                    Modify and fetch file offsets.
* mmap/munmap::             Memory mapping and requesting.
* getpid/getppid::          Get the PIDs of the caller.
* exec::                    Launching new programs.
* fork::                    Fork current state into a new process.
* wait::                    Waiting for execution of a child to finish.
* uname::                   Fetch basic system information.
* sethostname::             Hostname setting.
* fstat/lstat::             Fetch file information.
* getcwd/chdir::            Current working directory manipulation.
* ioctl::                   IO multiplexer.
* sched_yield::             Relinquish CPU time.
* getpriority/setpriority:: Manage scheduler priorities for processes.
* dup/dup2/dup3::           Duplicate file descriptors.
* access::                  Testing file permissions.
* thread_sched::            Manage scheduler-related thread permissions.
* fcntl::                   Multiplexed operations for files.
* spawn::                   Start separate programs by path.
* getrandom::               Bypass /dev/random for avoiding DoS attacks.
* mprotect::                Change memory permissions.
* crypto_request::          Access to kernel crypto ala /dev/crypto.

Devices and their properties

* Common devices::             Devices common to all architectures and targets.
* aarch64-stivale2 devices::   Devices specific to aarch64-stivale2.
* sparc-leon3 devices::        Devices specific to sparc-leon3.
* x86_64-multiboot2 devices::  Devices specific to x86_64-multiboot2.

@end detailmenu
@end menu

@node General information
@chapter General information

As the README of the project states, Ironclad is a kernel for x86_64 devices
exclusively (for now), written in Ada. The goal of the project is to create
a POSIX kernel for hobbyist fun, maybe one day for real life use. Ironclad has
a lot of features one would expect on a modern system, and the list only
continues to grow, like support for desktop environments, true multitasking, a
good memory manager, and a fully functional userland with dynamic linking and
ELF loading.

@node Audience
@section Audience

This manual is designed to document and give information about the several
interfaces and devices Ironclad exposes, so developers of userland applications
and other programmers can read inner details of how to interface with the
kernel without having to navigate the (often cryptic and scary Ada) code.

@node How to contribute
@section How to contribute

Thanks for considering contributing to Ironclad, it means a lot.

There are several ways one can help the Ironclad project, from writing and
correcting documentation to contributing source.

For submitting patches, be it for Ironclad's webpages, kernel code, or
documentation, please submit the patch to the project's
@url{https://savannah.nongnu.org/patch/?group=ironclad, patch manager},
(@url{https://savannah.nongnu.org/patch/?group=ironclad&func=additem, create an item}).

When contributing code, it's good to keep in mind these guidelines:

@enumerate
@item
One may only contribute code that complies with the project's license, or code
ruled by GPL-compatible licenses under certain conditions, its the
responsability of the contributor to ensure this is the case.

@item
Add license headers and detail the authors of the code. For files with a main
author and small touches being done on top of it, you can update the authors in
the copyright to `Copyright (C) 2022 [main author's name], et. al.`, or add
your name or pseudonym for a major contribution to the comma-separated list.

@item
It goes a long way to add the relevant documentation as comments and standalone
documentation when considered necessary. While not necessary, you save me the
trouble of having to add it later. :D
@end enumerate

@node Error reporting
@section Error reporting

Ironclad is a fairly new project at the end of the day, so things are prone to
fail. Once an issue arises, one can open a bug report at the
@url{https://savannah.nongnu.org/bugs/?group=ironclad, project's bug tracker},
(@url{https://savannah.nongnu.org/bugs/?group=ironclad&func=additem, create an item}).

@node Navigating the source
@section Navigating the source

The source of Ironclad can be found on its repository under the @code{source}
directory. It has several subdirectories with the following meanings:

@table @code
@item arch
Architecture-dependent code, including aarch64 and x86_64 code.

@item cryptography
Cryptographic facilities, cypher implementations, entropy management.

@item devices
Several device drivers, physical and virtual.

@item lib
Functions and libraries for utilities used in the rest of the kernel.

@item memory
Memory management, physical as well as virtual.

@item networking
Networking drivers and data.

@item userland
Userland code for loaders, processes, and such.

@item vfs
VFS structure and FS drivers.
@end table

Apart of those subdirectories, @code{source} itself contains the
@code{main.adb} of the kernel, @code{pragmas.adc} containing the pragmas used
for the rest of the kernel code, and some other files and drivers that do
not fit on the former subdirectories.

@node Formal verification
@section Formal verification

Right now the source of Ironclad is ongoing a process to raise its verification
status to @url{https://docs.adacore.com/spark2014-docs/html/ug/en/usage_scenarios.html#levels-of-spark-use, a mix of silver and gold level}.
This is done with the goal of ensure the absence of errors in a crucial system
component like the kernel, and for ensuring the suitability of Ironclad for
embedded and mission critical tasks.

@node Boot-time command-line options
@chapter Boot-time command-line options

Ironclad takes, as part of its boot protocol, a series of options and values.
The parsing of this options is architecture and platform independent, while the
ability to modify said options and values is entirely up to the platform and
bootloader.

@node Format
@section Format

The format is a list of keys that can have arguments or not in a C-style
NUL-terminted string, as such:

@example
key1=value1 key2 key3 ... keyN
@end example

@node List
@section List

This are the keys and values the kernel takes, and under which circumstances:

@table @code
@item root=<device>
Device to mount as root, if any.

@item init=<path>
Path to a program that will be booted by the kernel when finished loading.
The program will be started with @code{stdin} set to @code{/dev/null}, and
@code{stdout} and @code{stderr} set to @code{/dev/debug}.

@item syscalltracing
Enables tracing syscalls and their arguments, really performance taxing, but
essential for userland kernel debugging.
@end table

@node Embedded facilities and RTC
@chapter Embedded facilities and RTC

Ironclad supports several features geared towards embedded and real time work,
this section approaches what to expect and how to interact with the features.

@node Ticks and other interruptions
@section Ticks and other interruptions

Ironclad will not interrupt your running thread for timer or heartbeats, in
that way, ironclad is tickless.

However, Ironclad can interrupt a process for scheduling-related stops, this
is totally normal and can introduce substantial delays on systems with a lot
of processes, or introduce jitter on systems that desire absolutely 0 stops.

For how to get around scheduling-related ticks,
@xref{Real time and monothreaded scheduling}.

@node Scheduling priority intervals
@section Scheduling priority intervals

Scheduling in Ironclad is hardcoded to be done by a round robin (RR) with the
addition of priorities which rule how much time the process will be run for.

The amount of time each priority corresponds to is fixed, with the goal
of predictable outcome. Priorities can be modified for the running process
using @xref{getpriority/setpriority}.

Priorities map to execution times using the following table.

@table @code
@item -20 .. -15
30000ns

@item -14 .. -10
20000ns

@item -9 .. -1
15000ns

@item 0 (Default)
10000ns

@item 1 .. 9
8000ns

@item 10 .. 15
6000ns

@item 16 .. 19
5000ns
@end table

@node Real time and monothreaded scheduling
@section Real time and monothreaded scheduling

Scheduling in Ironclad supports two special, embedded-oriented modes, which
can be enabled or disabled using @xref{thread_sched} with @code{THREAD_RT} and
@code{THREAD_MONO}.

@itemize @bullet
@item
@code{THREAD_RT}: This flag enables real-time (RT) scheduling.

Under this mode, the kernel ensures that the thread will not be preemted by
non-RT threads. When preemted by another RT thread, the default semantics of
priority using POSIX's @xref{getpriority/setpriority} apply.

@item
@code{THREAD_MONO}: This flag will make the scheduler not preemt at all from
the thread once execution has already been engaged, effectively starting
cooperative multitasking.

This flag can be used for enforcing critical sections backed by the kernel in
single-core systems, or for keeping a sensor-polling service running constantly
for low latency, constant readings on important variables.

Using @xref{sched_yield} or relinquishing execution in any other similar way
will not reset the flag, but it will allow the system to search for another,
non-monothreaded, thread.

Notice that this flag does not imply the system runs only 1 thread, the kernel
will attempt to leverage other hardware cores for example to run several
threads at once if possible, it only ensures the given thread does not get
interrupted at all, and does not stop running until it says so.
@end itemize

@node Entering a real-time state
@section Entering a real-time state

Taking into account all the previous information, an appropiate sequence for
entering a real-time friendly state would be

@example
int main(void) @{
    // Set the running thread as RT/MLOCK.
    int sched_flags = get_thread_sched();
    if (set_thread_sched(sched_flags | THREAD_RT | THREAD_MLOCK) != 0) @{
        return -1;
    @}

    // Changes are effective next reschedule, else we cannot ensure the
    // scheduler will not interrupt us, the timer is already armed.
    sched_yield();

    // Welcome to RT land!

    // One can do anything here, this snippet will just exit.
    exit(0);
@}
@end example

@node Memory allocation algorithms
@chapter Memory allocation algorithms

Ironclad features several memory allocator choices for use by the userland
and kernel.

@node standard
@section standard

The standard allocator is a bitmap-based, simple allocator with 4K blocks.
The allocator allows freeing and has a moderate use of memory, it suffers from
heavy fragmentation for big allocations, and takes relatively a lot of memory
to upkeep.

@node alloconly
@section alloconly

'alloconly' is an alternative, bump-based allocator that is much faster and
uses way less memory than the standard allocator, while not being able to free
as its biggest trade-off.

This allocator is appropiate for embedded applications that are recommended
to allocate all the program will ever need at the beggining of its execution,
and thats it.

@node Userland state and conditions
@chapter Userland state and conditions

Ironclad places several requirements on loaded userland programs, from the
format of which, to memory layout.

@node Program loading and ld.so
@section Program loading and ld.so

Loaded programs must be under the ELF64 format, other formats may be supported
in the future. Loaded programs can be relocatable or not.

@code{ld.so} is a special case, it's loaded from the information on the headers
of the primary loaded program, and is assumed to be relocatable (static-PIE).

@node Memory layout
@section Memory layout

Loaded programs are loaded at address 0, and they are free to allocate
themselves at nearby offsets.

@code{ld.so} and entities like stacks, anonymous memory regions, and others,
will be randomized on load time following
@uref{https://en.wikipedia.org/wiki/Address_space_layout_randomization, ASLR},
and must not be relied upon. It is up to @code{ld.so} to optionally place
additionally loaded libraries at random offsets.

@node Syscalls
@chapter Syscalls

Syscalls in Ironclad have an architecture-dependent ABI, here is a list of the
supported architectures and the ABI for each of them.

@node x86_64
@section x86_64

Syscalls are invoked in Ironclad by triggering an interrupt to vector
@code{0x80}.

The index of the syscall is passed on @code{%rax}, while the return value is
returned on @code{%rax}, errno is returned on @code{%rdx}, arguments are passed
over @code{%rdi}, @code{%rsi}, @code{%rdx}, @code{%rcx}, @code{%r8}, and
@code{%r9}, following the SysV ABI.

The list of syscalls ordered by their index in @code{rax} for the platform is:

@enumerate 0
@item
@xref{exit}.
@item
@xref{arch_prctl}.
@item
@xref{open/close, open}.
@item
@xref{open/close, close}.
@item
@xref{read/write, read}.
@item
@xref{read/write, write}.
@item
@xref{seek}.
@item
@xref{mmap/munmap, mmap}.
@item
@xref{mmap/munmap, munmap}.
@item
@xref{getpid/getppid, getpid}.
@item
@xref{getpid/getppid, getppid}.
@item
@xref{exec}.
@item
@xref{fork}.
@item
@xref{wait}.
@item
@xref{uname}.
@item
@xref{sethostname}.
@item
@xref{fstat/lstat, fstat}.
@item
@pxref{fstat/lstat, lstat}.
@item
@xref{getcwd/chdir, getcwd}.
@item
@xref{getcwd/chdir, chdir}.
@item
@xref{ioctl}.
@item
@xref{sched_yield}.
@item
@xref{getpriority/setpriority, getpriority}.
@item
@pxref{getpriority/setpriority, setpriority}.
@item
@xref{dup/dup2/dup3, dup}.
@item
@xref{dup/dup2/dup3, dup2}.
@item
@pxref{dup/dup2/dup3, dup3}.
@item
@xref{access}.
@item
@xref{thread_sched, get_thread_sched}.
@item
@xref{thread_sched, set_thread_sched}.
@item
@xref{fcntl}
@item
@xref{spawn}
@item
@xref{getrandom}
@item
@xref{mprotect}
@item
@xref{crypto_request}
@end enumerate

@node Errno
@section Errno

Errno are values returned by the kernel to detail the nature of an error in
depth. When a syscall does not error out, it returns the value 0 on the errno
field. Here is a table of all the possible errno and its values and meaning:

@table @code
@item ERANGE (3)
The passed value was not big enough.

@item EACCES (1002)
The passed access for a variable points to bad memory.

@item EAGAIN (1006)
The requested resource is not available at the moment.

@item ECHILD (1012)
The passed value is not a child process.

@item EFAULT (1020)
The passed value would make the program fault.

@item EINVAL (1026)
The passed value is not valid for the called syscall.

@item EMFILE (1031)
Too many files were opened by the process.

@item ENAMETOOLONG (1036)
The passed value is too big for the syscall.

@item ENOENT (1043)
No such file or directory.

@item ENOSYS (1051)
The requested syscall or flag is not implemented.

@item ESPIPE (1069)
A seek was issued to an invalid device.

@item ESRCH (1070)
The passed item could not be found after a search.

@item ESPIPE (1081)
The passed FD is in a bad state.
@end table

@node exit
@section exit

@example
void exit(uint64_t status);
@end example

This syscall terminates the calling process "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return, thus, it has no return value or errno.

@node arch_prctl
@section arch_prctl

@example
int arch_prctl(int code, uint64_t argument);
@end example

This syscall interacts with architecture-specific thread-local storage. For
x86_64, these are the available codes:

@table @code
@item ARCH_SET_FS (1)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_FS (2)
Stores the current thread's FS into the variable pointed to by @code{argument}.

@item ARCH_SET_GS (3)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_GS (4)
Stores the current thread's GS into the variable pointed to by @code{argument}.
@end table

This syscall returns @code{0} on success, and @code{-1} on failure.
errno is to be set to the following values on failure:

@itemize @bullet
@item
@code{EINVAL}: @code{code} is not valid.

@item
@code{EFAULT}: @code{argument} is outside the available address space.
@end itemize

@node open/close
@section open/close

@example
int open(char *path, int flags, mode_t mode);
int close(int fd);
@end example

@code{open} opens the passed file, depending on the flags passed, it may create
it if not present. By default, the file descriptor will remain open accross an
@code{exec}, and the file offset is set to the beggining. @code{mode} is used
when creating the file.

The flags can be an OR'd field of the following elements:

@table @code
@item O_RDONLY (0b0001)
Makes the file read-only.

@item O_WRONLY (0b0010)
Makes the file write-only.

@item O_RDWR (0b0011)
Makes the file read/write.

@item O_APPEND (0b0100)
Makes the file be opened at the end of the file, instead of the beggining.

@item O_CREAT (0b1000)
Create the file if it does not exist.
@end table

@code{close} closes an open file descriptor. Once no open references exist of a
file descriptor, its resources are freed, and the file deleted if needed.

@code{open} returns the opened file descriptor or @code{-1} on error.
@code{close} returns 0 on success and -1 in failure.

errno is set according to the conditions for both functions:

@itemize @bullet
@item
@code{ENOENT}: The referenced file for @code{open} does not exist.

@item
@code{EMFILE}: Too many files are already owned by the process.

@item
@code{EFAULT}: The passed path is outside the available address space.

@item
@code{EBADF}: The passed file to @code{close} is not valid.
@end itemize

@node read/write
@section read/write

@example
ssize_t read(int fd, void *buffer, size_t count);
ssize_t write(int fd, void *buffer, size_t count);
@end example

These syscalls attempts to read or write up to passed count from the passed file descriptor.

On files that support seeking, the operation commences at the file offset, and
the file offset is incremented by the number of bytes read or written. If the
file offset is at or past the end of file, no bytes are read or written, and
the operation returns zero.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed fd is not suitable for the operation.
@end itemize

@node seek
@section seek

@example
off_t seek(int fd, off_t offset, int whence);
@end example

This syscall repositions the file offset of the passed file description to the
passed offset according to the directive whence as follows:

@itemize @bullet
@item
@code{SEEK_SET} (1): Set to the passed offset.

@code{SEEK_CUR} (2): Set to the current offset plus the passed offset.

@code{SEEK_END} (4): Set to the size of the file plus the passed offset.
@end itemize

This syscall returns the resulting offset, or @code{-1} on failure. errno is to
be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EINVAL}: The whence is malformed or the resulting offset would be invalid.

@item
@code{ESPIPE}: @code{seek} was called on a TTY or a pipe.
@end itemize

@node mmap/munmap
@section mmap/munmap

@example
void *mmap(void *hint, size_t length, int protection, int flags, int fd, off_t offset);
int munmap(void *address, size_t length);
@end example

@code{mmap} creates a new mapping in the virtual address space of the calling
process. An address can be passed, if it is @code{null}, then the kernel gets
to choose the address, else, it is taken as a hint about where to place the
mapping.

@code{hint} and @code{length} are required to be aligned to page boundaries
for the running architecture, else it will fail.

@code{protection} and @code{flags} are a bitfield of the following flags:

@itemize @bullet
@item
@code{PROT_NONE} (0b0000): No specific protection.

@item
@code{PROT_READ} (0b0001): Read permissions.

@item
@code{PROT_WRITE} (0b0010): Write permissions.

@item
@code{MAP_FIXED} (0b0100): Use hint as a hard requirement.

@item
@code{MAP_ANON} (0b1000): Mapping is not backed by any file.
@end itemize

@code{munmap} will unmap a range for the virtual address space of the calling
process, this values must be the same as passed and returned by @code{mmap},
partial unmapping is not allowed.

@code{mmap} returns a pointer to the allocated area, or @code{-1} on failure.
@code{munmap} returns @code{0} on success, @code{-1} on failure. Both functions
set @code{EINVAL} for bad hints or parameters.

@node getpid/getppid
@section getpid/getppid

@example
int getpid();
int getppid();
@end example

@code{getpid} returns the process ID (PID) of the calling process.
@code{getppid} does the same but it returns the one of the parent, which is the
process that created the callee by a myriad of ways.

This functions are always successful.

@node exec
@section exec

@example
int exec(const char *path, char *const argv[], char *const envp[]);
@end example

This syscall executes the program passed with the passed argv and evp, closing
all the threads of the callee process and putting a single one in place for
the new program. Other process-specific elements like file descriptors are
untouched.

This syscall only returns in failure with @code{-1} with the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file passed in path doesnt exist.

@item
@code{EACCES}: The file couldn't be launched out of a permission error.
@end itemize

@node fork
@section fork

@example
pid_t fork(void);
@end example

This syscall creates a new process by duplicating the calling process. The
process is referred to as the child process.The calling process is referred to
as the parent process. The processes run on copied memory, and at the time of
cloning have the same file descriptors open and memory mappings.

The child will only have the callee thread cloned. The other threads, if any,
are not cloned.

This syscall returns @code{0} on success for the child, and the children PID to
the parent, in failure, the parent gets @code{-1} with the following errno:

@itemize @bullet
@item
@code{EAGAIN}: The system could not fork right now, try again later.
@end itemize

@node wait
@section wait

@example
pid_t wait(pid_t pid, int *status, int options);
@end example

This syscall suspends execution until the passed pid exits, to then store the
exit code in @code{status}.

@code{wait} allows the option @code{WNOHANG(0b000010)} for non-blocking
waiting, if the process has not finished yet, @code{0} will be returned.

@code{pid} can be a PID the callee is a parent of, or @code{-1} to wait on all
the PIDs the callee has as children. @code{0}, which waits on all the children
of a process group, is not implemented yet.

This syscall returns the PID waited on or @code{-1} on failure, along with the
following errno:

@itemize @bullet
@item
@code{ECHILD}: The passed PID does not exist.

@item
@code{EINVAL}: The passed options are not correct or the passed PID is @code{0}
@end itemize

@node uname
@section uname

@example
struct utsname @{
    char sysname[65];  // Kernel name (e.g., "Ironclad")
    char nodename[65]; // Hostname of the machine.
    char release[65];  // Kernel release (e.g., "2.6.28")
    char version[65];  // Kernel configuration date for debug purposes.
    char machine[65];  // Hardware identifier (e.g., "x86")
@};

int uname(struct utsname *name);
@end example

This syscall reports kernel information, like version, name, and hostname.
It returns @code{0} on success, and @code{-1} on failure, with the only errno
being @code{EFAULT} if the passed pointer is in an invalid address.

@node sethostname
@section sethostname

@example
int sethostname(const char *buffer, size_t length);
@end example

This syscall sets the kernel hostname to the passed string. @code{0} is
returned on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed buffer points to an invalid address.

@item
@code{EINVAL}: The passed length is bigger than the kernel can handle or 0.
@end itemize

@node fstat/lstat
@section fstat/lstat

@example
struct stat @{
    dev_t st_dev;
    ino_t st_ino;
    mode_t st_mode;
    nlink_t st_nlink;
    uid_t st_uid;
    gid_t st_gid;
    dev_t st_rdev;
    off_t st_size;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    blksize_t st_blksize;
    blkcnt_t st_blocks;
@};

int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
@end example

This syscalls return information about a file. No permissions are required
for fetching the file information, but they are required for the containing
directories.

@code{0} is returned on success, @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The passed path or file descriptor is not valid.

@item
@code{EFAULT}: The passed address for the path or stat buffer is not valid.
@end itemize

@node getcwd/chdir
@section getcwd/chdir

@example
char *getcwd(char *buf, size_t size);
int chdir(const char *path);
@end example

This syscalls manage the current working directory of the callee process.
@code{getcwd} will fetch it as an absolute path, while chdir will set it with
a C-style string.

@code{getcwd} returns a pointer to the string passed, or @code{NULL} if the
string is not big enough, including @code{NUL}, and sets the following errno:

@itemize @bullet
@item
@code{EINVAL}: The passed length is 0.

@item
@code{ERANGE}: The passed buffer + size is not big enough for the path, and it
is safe to reallocate and try again.

@item
@code{EFAULT}: The passed buffer has a bad address.
@end itemize

@code{chdir} returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed path points to a bad address.

@item
@code{ENAMETOOLONG}: The passed path is too long.

@item
@code{ENOTDIR}: The passed path is not a directory or has 0 length.
@end itemize

@node ioctl
@section ioctl

@example
int ioctl(int fd, unsigned long request, void *argument);
@end example

This syscall manipulates the underlying device parameters of special files. It
allows a device-dependent API for fetching and setting several modes.

@code{ioctl} returns @code{0} on success and @code{-1} on failure, and sets the
following errno:

@itemize @bullet
@item
@code{ENOTTY}: The passed file does not support the passed ioctl.

@item
@code{EBADF}: The passed file does not exist for the process.

@item
@code{EFAULT}: The passed argument is in non-accesible memory
@end itemize

@node sched_yield
@section sched_yield

@example
int sched_yield(void);
@end example

This syscall relinquishes execution of the caller thread.
Its up for the kernel how far in the queue of execution this thread will go.

This syscall returns @code{0} always, as it never fails, this is done for
compatibility with POSIX instead of having a @code{void} return type.

@node getpriority/setpriority
@section getpriority/setpriority

@example
int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int prio);
@end example

This syscalls manage scheduler priority. @code{which} is a selector for the
kind of entity we are fetching and setting information for, right now only
@code{PRIO_PROCESS(1)} is supported.

Priority is a value in the range -20 to 19, with -20 being the highest priority
and 19 being the lowest priority. Attempts to set a priority outside this
range are silently clamped to the range. The default priority is 0; lower
values give a process a higher scheduling priority.

The @code{getpriority} call returns the highest priority (lowest numerical
value) enjoyed by any of the threads. @code{setpriority} sets the priorities of
all of the threads of the specified process to the passed value.

@code{getpriority} returns the priority in success or @code{-1} in failure,
note that @code{-1} is a valid return value, so @code{errno} must be cleared.
@code{setpriority} returns @code{0} on success and @code{-1} on failure.

Both syscalls set the following errno on failure:

@itemize @bullet
@item
@code{ENOSYS}: Any value different than @code{PRIO_PROCESS} was passed for
@code{which}

@item
@code{ESRCH}: The passed process could not be found.
@end itemize

@node dup/dup2/dup3
@section dup/dup2/dup3

@example
int dup(int oldfd);
int dup2(int oldfd, int newfd);
int dup3(int oldfd, int newfd, int flags);
@end example

This syscalls allocate new file descriptors pointing to the same file as the
passed file descriptor. @code{dup} chooses a descriptor itself, while
@code{dup2} and @code{dup3} will replace @code{newfd} with the new descriptor,
closing the old one if necessary.

The flags of the duplicated file descriptor are reset, this means
@code{O_CLOEXEC}, and other flags like @code{O_NONBLOCK} are not inherited. One
can use @code{dup3} to set those flags for the duplicated file descriptor using
the @code{flags} field.

All of these 3 syscalls return the new fd on success and @code{-1} on failure.
The errno codes set on failure are:

@itemize @bullet
@item
@code{EBADF}: The passed file descriptor is not owned by the process.

@item
@code{EMFILE}: Too many files have already been opened by the process.

@item
@code{EINVAL}: For @code{dup3}, @code{oldfd} and @code{newfd} are the same, or
flags are not @code{0} or @code{O_CLOEXEC}
@end itemize

@node access
@section access

@example
int access(const char *path, int mode);
@end example

This syscalls tests for file permissions and access without opening it.
@code{path} will be checked for a set of options or'd in @code{mode}, the
options are:

@itemize @bullet
@item
@code{F_OK (0b0001)}: The existance of the file is checked.

@item
@code{R_OK (0b0010)}: Being able to read the file is checked.

@item
@code{W_OK (0b0100)}: Being able to write to the file is checked.

@item
@code{X_OK (0b1000)}: The file being executable is checked.
@end itemize

The syscall returns @code{0} on success of checking the passed conditions
and @code{-1} on failure. The errno codes set on failure are:

@itemize @bullet
@item
@code{EFAULT}: The passed path points to invalid memory.

@item
@code{EINVAL}: The passed @code{mode} is not valid.

@item
@code{ENOENT}: The requested path to check does not exist.
@end itemize

@node thread_sched
@section thread_sched

@example
int get_thread_sched(void);
int set_thread_sched(int flags);
@end example

This syscalls manage scheduling properties of the callee thread. Both functions
operate on a bitmap with the following bits

@itemize @bullet
@item
@code{THREAD_RT (0b0001)}: Marks whether the thread is a real time thread, see
@xref{Real time and monothreaded scheduling} for details.

@item
@code{THREAD_MONO (0b0010)}: Marks whether the thread is a monothread, see
@xref{Real time and monothreaded scheduling} for details.

@item
@code{THREAD_MLOCK (0b0100)}: An mlock'ed thread will not allow its memory to
be swapped from memory, or altered by the kernel outside its control. This does
not include previously configured shared memory.

@item
@code{THREAD_BANNED (0b1000)}: A banned thread will get dequed permanently once
its execution slice is over, without being deleted. If set when calling
@code{set_thread_sched}, the thread will be dequed effective immediately.
@end itemize

These two syscalls do not fail, @code{get_thread_sched} returns the flags, and
@code{set_thread_sched} always returns 0, both syscalls return no @code{errno}.

@node fcntl
@section fcntl

@example
int fcntl(int fd, int cmd, int arg);
@end example

This syscall is a multiplexed syscall that performs the operations described
below on the open file descriptor @code{fd}. The operation is determined by
@code{cmd} and may take an optional argument @code{arg}.

The syscall's return value will depend on the requested @code{cmd}, and is
detailed along the operations below.

The valid operations are:

@itemize @bullet
@item
@code{F_GETFD (3)}: The flags used for @code{fd} will be returned, right now
only @code{FD_CLOEXEC} is supported. The syscall will return the flags on
success.

@item
@code{F_SETFD (4)}: The flags for @code{fd} will be set with @code{arg}. The
syscall will return @code{0} on sucess.
@end itemize

On failure, the syscall returns @code{-1}. The returned @code{errno} are:

@itemize @bullet
@item
@code{EINVAL}: The passed @code{cmd} is not implemented by the kernel.

@item
@code{EBADF}: The passed @code{fd} is not open.
@end itemize

@node spawn
@section spawn

@example
pid_t spawn(const char *path, char *const argv[], char *const envp[]);
@end example

This syscall creates a new process and executes the program located at
@code{path}, passing it @code{argv} and @code{envp}. The new process inherits
nothing from the parent except duplicating its @code{stdin}, @code{stdout}, and
@code{stderr} for itself.

@code{spawn} is intended as a replacement for the @code{fork}/@code{exec}
idiom, while requiring no MMU support or intermediary address space copies,
making it more portable and faster.

The syscall returns the pid of the created process or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file pointed by @code{path} does not exist.

@item
@code{EAGAIN}: The process could not be created, please try again later.

@item
@code{EACCES}: The file couldn't be launched out of a permission error.
@end itemize

@node getrandom
@section getrandom

@example
ssize_t getrandom(void *buffer, size_t length);
@end example

This syscall fills the buffer pointed to @code{buffer} with up to @code{length}
random bytes. These bytes can be used for cryptographic purposes.

The operation is the same as reading from @code{/dev/random}. It is provided
instead of just reading from the device as to avoid denial of service attacks
based on exhausting the file descriptor limit of the system, along with other
vulnerabilities and inconveniences related to the classic file interface.

The syscall returns the count of read random data or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{buffer} points to invalid memory.
@end itemize

@node mprotect
@section mprotect

@example
int mprotect(void *addr, size_t len, int prot);
@end example

This syscall allows to change the permission of a range of memory of the passed
length pointed by @code{addr}, previously mapped by the caller. The format of
@code{prot} is the same as @code{mmap}.

@code{addr} and @code{len} must be aligned to an architecture-valid alignment.

The syscall returns the @code{0} on success or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{addr} points to invalid memory.
@end itemize

@node crypto_request
@section crypto_request

@example
int crypto_request(unsigned long request, void *argument);
@end example

This syscall exposes kernel cryptographic facilities on the same way
@code{ioctl} does for the @code{/dev/crypto} pseudo-device in OpenBSD systems.
A series of authentication and encryption algorithms are supported.

All the modes available and their @code{argument} are:

@table @code
@item CRYPTO_AES128_ECB_ENCRYPT (0)
@itemx CRYPTO_AES128_ECB_DECRYPT (1)
@itemx CRYPTO_AES128_CBC_DECRYPT (2)
@itemx CRYPTO_AES128_CBC_DECRYPT (3)

When using these encryption algorithms, @code{argument} points to a structure
with the form:
@example
struct crypto_aes_data @{
   __uint128_t  key;    // Key for the AES encryption.
   __uint128_t  iv;     // Initialization vector when needed.
   void        *data;   // Data pointer.
   uint32_t     length; // Length, must be a multiple of 16.
@}
@end example

These request will encrypt or decrypt @code{length} bytes of data in-place
pointed by @code{data}, @code{length} must be divisible by 16 (128-bit blocks).
@end table

The syscall returns @code{0} on success, or @code{-1} on failure, and
sets the following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{argument} points to invalid memory.

@item
@code{ENOSYS}: @code{request} is not implemented by the hardware.
@end itemize

@node Devices and their properties
@chapter Devices and their properties

Ironclad exposes a number of devices, physical and virtual, to userland. All
of them are exposed under the @code{/dev} location, and support a series of
standard operations, like being manipulated by the usual file-related
syscalls like @code{read} or @code{write}, while sporting device-specific
interfaces in the form of device-specific @code{ioctl} requests.

The devices detailed in this chapter are divided in "Common devices", which
are devices featured regardless of the architecture running Ironclad, and
architecture-specific devices.

@node Common devices
@section Common devices

@subsection debug

@code{/dev/debug} wraps architecture-specific debug output channels for use
with file operations. For x86-based targets, this is QEMU's E9, for arm-based
and sparc-based targets, this is UART.

@subsection ramdev

The devices starting by @code{ramdev} are virtual devices representing the
RAM driver passed by some boot protocols, an FS can be mounted to them, usually
USTAR. These RAM devices are exclusively read-only.

@subsection random

The device @code{random} is equivalent to the one featured in other unix-like
kernels. Keep in mind that Ironclad has limited sources of entropy, so the
quality of this random numbers is a bit limited. Writing to the source is not
allowed, unlike other systems.

@code{/dev/urandom} does the same as @code{/dev/random}, and is only provided
for compatibility.

@code{getrandom} is provided as well for avoiding the file interface.

@subsection null/zero

@code{null} and @code{zero} are the equivalent of the @code{null} and
@code{zero} devices for platforms like Linux.

@code{null} returns @code{EOF} whenever read, and all the write operations are
discarded.

@code{zero} returns exclusively a stream of zeros when read, and all write
operations are discarded.

@node aarch64-stivale2 devices
@section aarch64-stivale2 devices

@subsection pl011

The device @code{pl011} supports read operations for PL011 UART compatible
devices.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented, only the ones related to input stream
settings.

The default baud for the device is set to be @code{115200}.

@node sparc-leon3 devices
@section sparc-leon3 devices

This target has no special devices.

@node x86_64-multiboot2 devices
@section x86_64-multiboot2 devices

@subsection bootfb

The @code{bootfb} device exposes the framebuffer passed as part of the
boot-protocol, when present. The device is not accessible by normal @code{read}
and @code{write} calls, and must be @code{mmap}'d for operating on it.

The @code{bootfb} device has a special @code{ioctl} call, which has an
argument with the following structure:

@example
FB_DIMENSIONS = 1
struct fb_dimensions @{
   uint32_t width;
   uint32_t height;
   uint32_t pitch;
   uint8_t  bpp;
@};

ioctl(fb, FB_DIMENTIONS, pointer_to_fb_dimensions)
@end example

@subsection ps2keyboard/ps2mouse

The devices @code{ps2keyboard} and @code{ps2mouse} exposes x86's native PS2
interfaces, @code{ps2keyboard} is a normal character device, while
@code{ps2mouse} is a character device that returns mouse packets under the
structure:

@example
struct mouse_data @{
   uint32_t x_variation;
   uint32_t y_variation;
   uint8_t  is_left_click;
   uint8_t  is_right_click;
@};
@end example

@code{ps2mouse} supports a series of @code{ioctl} calls for setting different
modes and talking directly with the PS2 controller:

@example
PS2MOUSE_2_1_SCALING     = 1
PS2MOUSE_1_1_SCALING     = 2
PS2MOUSE_SET_RES         = 3
PS2MOUSE_SET_SAMPLE_RATE = 4

ioctl(mouse, PS2MOUSE_2_1_SCALING, ignored);  // Enable 2:1 scaling.
ioctl(mouse, PS2MOUSE_1_1_SCALING, ignored);  // Enable 1:1 scaling.
ioctl(mouse, PS2MOUSE_SET_RES, resolution);   // Set resolution (0 - 3).
ioctl(mouse, PS2MOUSE_SET_SAMPLE_RATE, rate); // Set sample rate (0 - 200).
@end example

Valid resolutions and sample rates are values for the PS2 controller, else
the call is ignored. For valid values and their meaning refer to
@uref{https://isdaman.com/alsos/hardware/mouse/ps2interface.htm, this website}.

@subsection serial

The devices starting by @code{serial} represent the several character devices
used for each present serial port, they support read/write operations, but no
TTY interface is exposed, they are raw byte streams.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented as the serial devices are not ttys but
just byte streams.

The default baud for all ports is set to be @code{115200}.

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texi

@bye
